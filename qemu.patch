diff --git a/configs/devices/arm-softmmu/default.mak b/configs/devices/arm-softmmu/default.mak
index 31f77c2026..096d5ee246 100644
--- a/configs/devices/arm-softmmu/default.mak
+++ b/configs/devices/arm-softmmu/default.mak
@@ -49,3 +49,5 @@
 # CONFIG_FSL_IMX7=n
 # CONFIG_FSL_IMX6UL=n
 # CONFIG_ALLWINNER_H3=n
+
+CONFIG_S32K358=y
diff --git a/hw/arm/Kconfig b/hw/arm/Kconfig
index 1ad60da7aa..07ce612521 100644
--- a/hw/arm/Kconfig
+++ b/hw/arm/Kconfig
@@ -712,3 +712,18 @@ config ARMSSE
     select UNIMP
     select SSE_COUNTER
     select SSE_TIMER
+
+config S32K358
+    bool
+    default y
+    depends on TCG && ARM
+    select ARMSSE
+    select MPS2_SCC
+    select OR_IRQ
+    select PL022    # SPI
+    select PL080    # DMA controller
+    select SPLIT_IRQ
+    select UNIMP
+    select S32K358_TIMER
+    select S32K358_UART
+    select CMSDK_APB_WATCHDOG
diff --git a/hw/arm/meson.build b/hw/arm/meson.build
index 0c07ab522f..ea82ee5967 100644
--- a/hw/arm/meson.build
+++ b/hw/arm/meson.build
@@ -78,4 +78,6 @@ system_ss.add(when: 'CONFIG_VERSATILE', if_true: files('versatilepb.c'))
 system_ss.add(when: 'CONFIG_VEXPRESS', if_true: files('vexpress.c'))
 system_ss.add(when: 'CONFIG_Z2', if_true: files('z2.c'))
 
+arm_ss.add(when: 'CONFIG_S32K358', if_true: files('s32k358.c'))
+
 hw_arch += {'arm': arm_ss}
diff --git a/hw/arm/s32k358.c b/hw/arm/s32k358.c
new file mode 100644
index 0000000000..5f7d7b8b8c
--- /dev/null
+++ b/hw/arm/s32k358.c
@@ -0,0 +1,208 @@
+/*
+ * ARM s32k358 board emulation.
+ *
+ * SPDX-License-Identifier: CC-BY-NC-4.0
+ * Copyright (c) 2025 Braidotti Sara, Iorio Chiara, Pani Matteo.
+ *
+ */
+
+#include "qemu/osdep.h" // Pull in some common system headers that most code in QEMU will want
+#include "qemu/units.h" // Simply defines KiB, MiB
+#include "qemu/cutils.h" // Defines some function about strings
+#include "qapi/error.h" // Error reporting system loosely patterned after Glib's GError.
+#include "qemu/error-report.h" // error reporting
+#include "hw/arm/boot.h" // ARM kernel loader.
+#include "hw/arm/armv7m.h" // ARMv7M CPU object
+#include "hw/or-irq.h" // for interrupt reqest
+#include "hw/boards.h" //  Declarations for use by board files for creating devices (e.g machine_type_name)
+#include "exec/address-spaces.h" //  Internal memory management interfaces
+#include "sysemu/sysemu.h" // Misc. things related to the system emulator.
+#include "hw/qdev-properties.h" // Define device properties
+#include "hw/misc/unimp.h" // create_unimplemented_device
+#include "hw/char/s32k358_uart.h"
+#include "hw/misc/mps2-scc.h" // ARM MPS2 SCC emulation
+#include "hw/misc/mps2-fpgaio.h" // ARM MPS2 FPGAIO emulation
+#include "hw/ssi/pl022.h" // Arm PrimeCell PL022 Synchronous Serial Port
+#include "hw/i2c/arm_sbcon_i2c.h" // ARM Versatile I2C controller
+#include "hw/net/lan9118.h" // SMSC LAN9118 Ethernet interface emulation
+#include "net/net.h" // Net configurations (clients, sockets,...)
+#include "hw/watchdog/cmsdk-apb-watchdog.h" // This is a model of the "APB watchdog" which is part of the Cortex-M System Design Kit
+#include "hw/qdev-clock.h" // Device's clock input and output
+#include "qapi/qmp/qlist.h" // QList Module (provides dynamic arrays)
+#include "qom/object.h" // QEMU Object Model
+#include "hw/timer/s32k358_timer.h"
+
+// Data types representing the machine
+struct S32K358MachineClass {
+    MachineClass parent;
+};
+
+struct S32K358MachineState {
+    MachineState parent;
+    ARMv7MState armv7m; // CPU
+    MemoryRegion utest;
+    MemoryRegion cflash0; // Code flash
+    MemoryRegion cflash1;
+    MemoryRegion cflash2;
+    MemoryRegion cflash3;
+    MemoryRegion dflash0; // Data flash
+    MemoryRegion itcm0; // memory located in 0x0, here we put the interrupt vector table
+    MemoryRegion dtcm0;
+    MemoryRegion sram0; // RAM
+    MemoryRegion sram1;
+    MemoryRegion sram2;
+    S32K358Timer timer[3];
+    Clock *sysclk; // Clock
+    Clock *refclk;
+};
+
+#define TYPE_S32K358_MACHINE MACHINE_TYPE_NAME("s32k358")
+
+OBJECT_DECLARE_TYPE(S32K358MachineState, S32K358MachineClass, S32K358_MACHINE)
+
+
+/* Main SYSCLK frequency in Hz */
+/* Accordimg to the documentation, it can run up to 240 MHz */
+/* We found this value in the offical freeRTOS demo for s32k3x8 */
+#define SYSCLK_FRQ 24000000
+
+/*
+ * The Application Notes don't say anything about how the
+ * systick reference clock is configured. (Quite possibly
+ * they don't have one at all.) This 1MHz clock matches the
+ * pre-existing behaviour that used to be hardcoded in the
+ * armv7m_systick implementation.
+ */
+#define REFCLK_FRQ (1 * 1000 * 1000)
+
+/* Initialize the auxiliary RAM region @mr and map it into
+ * the memory map at @base.
+ */
+static void make_ram(MemoryRegion *system_memory, MemoryRegion *mr,
+                     const char *name, hwaddr base, hwaddr size)
+{
+    memory_region_init_ram(mr, NULL, name, size, &error_fatal);
+    memory_region_add_subregion(system_memory, base, mr);
+}
+
+static void s32k358_init(MachineState *machine)
+{
+    S32K358MachineState *mms = S32K358_MACHINE(machine);
+    MemoryRegion *system_memory = get_system_memory();
+    DeviceState *armv7m;
+    int i;
+
+    /* This clock doesn't need migration because it is fixed-frequency */
+    mms->sysclk = clock_new(OBJECT(machine), "SYSCLK");
+    clock_set_hz(mms->sysclk, SYSCLK_FRQ);
+
+    mms->refclk = clock_new(OBJECT(machine), "REFCLK");
+    clock_set_hz(mms->refclk, REFCLK_FRQ);
+
+    /*
+     * Memory regions on the system
+     * We need to define the base address and the size of each memory space
+     * Refer to pages 3 (Flash memories) and 13 (RAM memories) of the S32K3 Memories Guide
+     * Create the memory region, add it to the memory regions of the system and finally link it to the CPU
+    */
+
+    make_ram(system_memory, &mms->itcm0, "s32k358.itcm0", 0x00000000, 0x10000);
+    make_ram(system_memory, &mms->cflash0, "s32k358.cflash0", 0x00400000, 0x200000);
+    make_ram(system_memory, &mms->cflash1, "s32k358.cflash1", 0x00600000, 0x200000);
+    make_ram(system_memory, &mms->cflash2, "s32k358.cflash2", 0x00800000, 0x200000);
+    make_ram(system_memory, &mms->cflash3, "s32k358.cflash3", 0x00A00000, 0x200000);
+    make_ram(system_memory, &mms->dflash0, "s32k358.dflash0", 0x10000000, 0x20000);
+    make_ram(system_memory, &mms->dtcm0, "s32k358.dtcm0", 0x20000000, 0x20000);
+    make_ram(system_memory, &mms->utest, "s32k358.utest", 0x1B000000, 0x2000);
+    make_ram(system_memory, &mms->sram0, "s32k358.sram0", 0x20400000, 0x40000);
+    make_ram(system_memory, &mms->sram1, "s32k358.sram1", 0x20440000, 0x40000);
+    make_ram(system_memory, &mms->sram2, "s32k358.sram2", 0x20480000, 0x40000);
+
+    // CPU: arm-cortex-m7
+    object_initialize_child(OBJECT(mms), "armv7m", &mms->armv7m, TYPE_ARMV7M);
+    armv7m = DEVICE(&mms->armv7m);
+    // Number of interrupts (see interrupt map)
+    qdev_prop_set_uint32(armv7m, "num-irq", 240);
+
+    qdev_connect_clock_in(armv7m, "cpuclk", mms->sysclk);
+    qdev_connect_clock_in(armv7m, "refclk", mms->refclk);
+    qdev_prop_set_string(armv7m, "cpu-type", machine->cpu_type);
+    qdev_prop_set_bit(armv7m, "enable-bitband", true);
+    object_property_set_link(OBJECT(&mms->armv7m), "memory",
+                             OBJECT(system_memory), &error_abort);
+    sysbus_realize(SYS_BUS_DEVICE(&mms->armv7m), &error_fatal);
+
+    // UART
+    static const hwaddr uartbase[] = {0x40328000, 0x4032C000, 0x40330000, 0x40334000,
+                                        0x40338000, 0x4033C000, 0x40340000, 0x40344000,
+                                        0x4048C000, 0x40490000, 0x40494000, 0x40498000,
+                                        0x4049C000, 0x404A0000, 0x404A4000, 0X404A8000
+                                        };
+    static const int uartirq_base = 141;
+
+
+    for (i = 0; i < 16; i++) {
+        DeviceState *dev;
+        SysBusDevice *s;
+
+        dev = qdev_new(TYPE_S32K358_LPUART);
+        s = SYS_BUS_DEVICE(dev);
+        qdev_prop_set_chr(dev, "chardev", serial_hd(i));
+        qdev_prop_set_uint32(dev, "pclk-frq", SYSCLK_FRQ);
+        qdev_prop_set_uint32(dev, "id", i);
+        sysbus_realize_and_unref(s, &error_fatal);
+        sysbus_mmio_map(s, 0, uartbase[i]);
+        sysbus_connect_irq(s, 0, qdev_get_gpio_in(armv7m, uartirq_base + i));
+    }
+
+    // Timers - refer to page 2816 of the manual (68.7.1)
+    static const hwaddr timerbase[] = {0x400B0000, 0x400B4000, 0x402FC000};
+    // irq from the s32kxxrm interrupt map
+    int irqno[] = {96, 97, 98};
+
+    // Create the timers and connect them
+    for (i = 0; i < ARRAY_SIZE(mms->timer); i++) {
+        g_autofree char *name = g_strdup_printf("timer%d", i);
+        SysBusDevice *sbd;
+
+        object_initialize_child(OBJECT(mms), name, &mms->timer[i],
+                                TYPE_S32K358_TIMER);
+        sbd = SYS_BUS_DEVICE(&mms->timer[i]);
+        qdev_connect_clock_in(DEVICE(&mms->timer[i]), "pclk", mms->sysclk);
+        sysbus_realize_and_unref(sbd, &error_fatal);
+        sysbus_mmio_map(sbd, 0, timerbase[i]);
+        sysbus_connect_irq(sbd, 0, qdev_get_gpio_in(armv7m, irqno[i]));
+    }
+
+    // Address from which load the kernel
+    // The address specified here is usually not used
+    // (only if it's not specified in the elf file)
+    armv7m_load_kernel(ARM_CPU(first_cpu), machine->kernel_filename,
+                       0x00400000, 0x200000);
+}
+
+// Machine init
+static void s32k358_class_init(ObjectClass *oc, void *data)
+{
+    MachineClass *mc = MACHINE_CLASS(oc);
+
+    mc->init = s32k358_init;
+    mc->max_cpus = 1;
+    mc->default_cpu_type = ARM_CPU_TYPE_NAME("cortex-m7");
+    mc->desc = "ARM S32K358";
+}
+
+static const TypeInfo s32k358_info = {
+    .name = TYPE_S32K358_MACHINE,
+    .parent = TYPE_MACHINE,
+    .instance_size = sizeof(S32K358MachineState),
+    .class_size = sizeof(S32K358MachineClass),
+    .class_init = s32k358_class_init,
+};
+
+static void s32k358_machine_init(void)
+{
+    type_register_static(&s32k358_info);
+}
+
+type_init(s32k358_machine_init);
diff --git a/hw/char/Kconfig b/hw/char/Kconfig
index 4fd74ea878..3ae728d677 100644
--- a/hw/char/Kconfig
+++ b/hw/char/Kconfig
@@ -74,3 +74,6 @@ config GOLDFISH_TTY
 
 config SHAKTI_UART
     bool
+
+config S32K358_UART
+    bool
diff --git a/hw/char/meson.build b/hw/char/meson.build
index e5b13b6958..517d802f5d 100644
--- a/hw/char/meson.build
+++ b/hw/char/meson.build
@@ -39,3 +39,5 @@ system_ss.add(when: 'CONFIG_GOLDFISH_TTY', if_true: files('goldfish_tty.c'))
 specific_ss.add(when: 'CONFIG_TERMINAL3270', if_true: files('terminal3270.c'))
 specific_ss.add(when: 'CONFIG_VIRTIO', if_true: files('virtio-serial-bus.c'))
 specific_ss.add(when: 'CONFIG_PSERIES', if_true: files('spapr_vty.c'))
+
+specific_ss.add(when: 'CONFIG_S32K358_UART', if_true: files('s32k358_uart.c'))
diff --git a/hw/char/s32k358_uart.c b/hw/char/s32k358_uart.c
new file mode 100644
index 0000000000..b4ea414875
--- /dev/null
+++ b/hw/char/s32k358_uart.c
@@ -0,0 +1,632 @@
+/*
+  * S32K358 LPUART emulation
+ *
+ * SPDX-License-Identifier: CC-BY-NC-4.0
+ * Copyright (c) 2025 Braidotti Sara, Iorio Chiara, Pani Matteo.
+ *
+ */
+
+#include "qemu/osdep.h"
+#include "qemu/log.h"
+#include "qemu/module.h"
+#include "qapi/error.h"
+#include "trace.h"
+#include "hw/sysbus.h"
+#include "migration/vmstate.h"
+#include "hw/registerfields.h"
+#include "chardev/char-fe.h"
+#include "chardev/char-serial.h"
+#include "hw/char/s32k358_uart.h"
+#include "hw/irq.h"
+#include "hw/qdev-properties-system.h"
+
+REG32(VERID, 0x0)
+REG32(PARAM, 0x4)
+REG32(GLOBAL, 0x8)
+    FIELD(GLOBAL, RST, 1, 1)
+REG32(BAUD, 0x10)
+    FIELD(BAUD, SBR, 0, 13)
+    FIELD(BAUD, SBNS, 13, 1)
+    FIELD(BAUD, BOTHEDGE, 17, 1)
+    FIELD(BAUD, OSR, 24, 5)
+REG32(STAT, 0x14)
+    FIELD(STAT, RDRF, 21, 1)
+    FIELD(STAT, TC, 22, 1)
+    FIELD(STAT, TDRE, 23, 1)
+REG32(CTRL, 0x18)
+    FIELD(CTRL, PT, 0, 1)
+    FIELD(CTRL, PE, 1, 1)
+    FIELD(CTRL, RE, 18, 1)
+    FIELD(CTRL, TE, 19, 1)
+    FIELD(CTRL, RIE, 21, 1)
+    FIELD(CTRL, TCIE, 22, 1)
+    FIELD(CTRL, TIE, 23, 1)
+REG32(DATA, 0x1C)
+    FIELD(DATA, R07T07, 0, 8)
+REG32(FIFO, 0x28)
+    FIELD(FIFO, RXFIFOSIZE, 0, 3)
+    FIELD(FIFO, RXFE, 3, 1)
+    FIELD(FIFO, TXFIFOSIZE, 4, 3)
+    FIELD(FIFO, TXFE, 7, 1)
+    FIELD(FIFO, RXUFE, 8, 1)
+    FIELD(FIFO, TXOFE, 9, 1)
+    FIELD(FIFO, RXFLUSH, 14, 1)
+    FIELD(FIFO, TXFLUSH, 15, 1)
+    FIELD(FIFO, RXUF, 16, 1)
+    FIELD(FIFO, TXOF, 17, 1)
+    FIELD(FIFO, RXEMPT, 22, 1)
+    FIELD(FIFO, TXEMPT, 23, 1)
+REG32(WATER, 0x2C)
+    FIELD(WATER, TXWATER, 0, 4)
+    FIELD(WATER, TXWATER_SHORT, 0, 2)
+    FIELD(WATER, TXCOUNT, 8, 5)
+    FIELD(WATER, RXWATER, 16, 4)
+    FIELD(WATER, RXWATER_SHORT, 16, 2)
+    FIELD(WATER, RXCOUNT, 24, 5)
+
+static void lpuart_update_parameters(S32K358LPUART *s)
+{
+    QEMUSerialSetParams ssp;
+
+    uint8_t osr = (s->baud & R_BAUD_OSR_MASK) >> R_BAUD_OSR_SHIFT;
+
+    if (!osr)
+        osr = 15;
+
+    // Configure the parity bit
+    if (s->ctrl & R_CTRL_PE_MASK) {
+        if (s->ctrl & R_CTRL_PT_MASK) {
+            ssp.parity = 'O';
+        } else {
+            ssp.parity = 'E';
+        }
+    } else {
+        ssp.parity = 'N';
+    }
+
+    // By default, the data size is always 8
+    ssp.data_bits = 8;
+
+    // Configure one or two stop bits
+    if (!(s->baud & R_BAUD_SBNS_MASK))
+        ssp.stop_bits = 1;
+    else
+        ssp.stop_bits = 2;
+
+    // Configure the baud rate
+    // Computation at page 4618: baud_rate = clock / ((OSR+1) * SBR)
+    if ((s->baud & R_BAUD_SBR_MASK))
+        ssp.speed = s->pclk_frq / ((((s->baud & R_BAUD_OSR_MASK) >> R_BAUD_OSR_SHIFT) + 1) * (s->baud & R_BAUD_SBR_MASK));
+    else
+        ssp.speed = s->pclk_frq;
+
+    qemu_chr_fe_ioctl(&s->chr, CHR_IOCTL_SERIAL_SET_PARAMS, &ssp);
+}
+
+static void lpuart_update_watermark(S32K358LPUART *s)
+{
+    if (s->tx_fifo_written > s->tx_fifo_watermark)
+        s->stat &= ~R_STAT_TDRE_MASK;
+    else
+        s->stat |= R_STAT_TDRE_MASK;
+
+    if (s->rx_fifo_written > s->rx_fifo_watermark)
+        s->stat |= R_STAT_RDRF_MASK;
+    else
+        s->stat &= ~R_STAT_RDRF_MASK;
+}
+
+static void lpuart_update_irq(S32K358LPUART *s)
+{
+    if (((s->ctrl & R_CTRL_TIE_MASK) && (s->stat & R_STAT_TDRE_MASK)) || // there is room in the transmit FIFO to write another transmit character to Data
+        ((s->ctrl & R_CTRL_TCIE_MASK) && (s->stat & R_STAT_TC_MASK)) || // the transmitter is finished transmitting all data and is idle
+        ((s->ctrl & R_CTRL_RIE_MASK) && (s->stat & R_STAT_RDRF_MASK)) || // the receive FIFO level is greater than the watermark
+        ((s->fifo & R_FIFO_TXOFE_MASK) && (s->fifo & R_FIFO_TXOF_MASK)) || // transmitter FIFO overflow
+        ((s->fifo & R_FIFO_RXUFE_MASK) && (s->fifo & R_FIFO_RXUF_MASK))) // receiver FIFO underflow
+         qemu_set_irq(s->uartint, 1);
+
+    else
+        qemu_set_irq(s->uartint, 0);
+}
+
+static void lpuart_reset(DeviceState *dev)
+{
+    S32K358LPUART *s = S32K358_LPUART(dev);
+
+    // reset values for lpuart0 and lpuart1
+    if (s->id < 2) {
+        s->verid = 0x04040007;
+        s->param = 0x00000404;
+        s->fifo = 0x00C00033;
+    } else { // reset values for lpuart2 ... lpuart15
+        s->verid = 0x04040003;
+        s->param = 0x00000202;
+        s->fifo = 0x00C00011;
+    }
+    s->global = 0;
+    s->baud = 0x0F000004;
+    s->stat = 0x00C00000;
+    s->ctrl = 0;
+    s->data = 0x00001000;
+    s->tx_fifo_written = 0;
+    s->rx_fifo_written = 0;
+    s->rx_fifo_watermark = 0;
+    s->tx_fifo_watermark = 0;
+    // Fifo is disabled
+    s->tx_fifo_size = 1;
+    s->rx_fifo_size = 1;
+
+    lpuart_update_parameters(s);
+    lpuart_update_irq(s);
+}
+
+static int lpuart_can_receive(void *opaque)
+{
+    S32K358LPUART *s = S32K358_LPUART(opaque);
+
+    // Check that the receiver is enabled
+    if (!(s->ctrl & R_CTRL_RE_MASK))
+        return 0;
+
+    // Returns the amount of data that the frontend can receive
+    return s->rx_fifo_size - s->rx_fifo_written;
+}
+
+static void lpuart_receive(void *opaque, const uint8_t *buf, int size)
+{
+    S32K358LPUART *s = S32K358_LPUART(opaque);
+
+    /* In fact lpuart_can_receive() ensures that we can't be
+      * called unless RX is enabled and the buffer is empty,
+      * but we include this logic as documentation of what the
+      * hardware does if a character arrives in these circumstances.
+      */
+    if (!(s->ctrl & R_CTRL_RE_MASK)) {
+        // Just drop the character on the floor
+        return;
+    }
+
+    memcpy(s->rx_fifo + s->rx_fifo_written, buf, 1);
+    s->rx_fifo_written++;
+    // the receive fifo is no more empty
+    s->fifo &= ~R_FIFO_RXEMPT_MASK;
+
+    lpuart_update_watermark(s);
+    lpuart_update_irq(s);
+}
+
+static void lpuart_read_rx_fifo(S32K358LPUART *s) {
+    if (s->rx_fifo_written == 0) {
+        s->fifo |= R_FIFO_RXUF_MASK;
+        lpuart_update_irq(s);
+        return;
+    }
+
+    s->data &= ~R_DATA_R07T07_MASK;
+    s->data |= s->rx_fifo[0];
+    s->rx_fifo_written--;
+    if (s->rx_fifo_written == 0)
+        s->fifo |= R_FIFO_RXEMPT_MASK;
+    else
+        memmove(s->rx_fifo, s->rx_fifo + 1, s->rx_fifo_written);
+
+    lpuart_update_watermark(s);
+    lpuart_update_irq(s);
+}
+
+static uint64_t lpuart_read(void *opaque, hwaddr offset, unsigned size)
+{
+    S32K358LPUART *s = S32K358_LPUART(opaque);
+    uint64_t r;
+
+    switch (offset) {
+    case A_BAUD:
+        r = s->baud;
+        break;
+    case A_CTRL:
+        r = s->ctrl;
+        break;
+    case A_DATA:
+        lpuart_read_rx_fifo(s);
+        r = s->data;
+        break;
+    case A_FIFO:
+        r = s->fifo;
+        break;
+    case A_GLOBAL:
+        r = s->global;
+        break;
+    case A_PARAM:
+        r = s->param;
+        break;
+    case A_STAT:
+        r = s->stat;
+        break;
+    case A_VERID:
+        r = s->verid;
+        break;
+    case A_WATER:
+        r = ((s->rx_fifo_written) << R_WATER_RXCOUNT_SHIFT) | ((s->rx_fifo_watermark) << R_WATER_RXWATER_SHIFT) |
+                ((s->tx_fifo_written) << R_WATER_TXCOUNT_SHIFT) | ((s->tx_fifo_watermark) << R_WATER_TXWATER_SHIFT);
+        break;
+    default:
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "s32k358 LPUART read: bad offset %x\n", (int) offset);
+        r = 0;
+        break;
+    }
+
+    return r;
+}
+
+/* Try to send tx data, and arrange to be called back later if
+ * we can't (ie the char backend is busy/blocking).
+ */
+static gboolean lpuart_transmit(void *do_not_use, GIOCondition cond, void *opaque)
+{
+    S32K358LPUART *s = S32K358_LPUART(opaque);
+    int ret;
+
+    /* instant drain the fifo when there's no back-end */
+    if (!qemu_chr_fe_backend_connected(&s->chr)) {
+        s->tx_fifo_written = 0;
+        return G_SOURCE_REMOVE;
+    }
+
+    // Verify that the transmitter is enabled
+    if (!(s->ctrl & R_CTRL_TE_MASK)) {
+        return G_SOURCE_REMOVE;
+    }
+
+    // Verify that there is something to transmit
+    if (s->fifo & R_FIFO_TXEMPT_MASK) {
+        return G_SOURCE_REMOVE;
+    }
+
+    // Transmission from front-end to back-enc
+    ret = qemu_chr_fe_write(&s->chr, s->tx_fifo, s->tx_fifo_written);
+
+    // Update the number of elements in the fifo and shift the fifo
+    if (ret >= 0) {
+        s->tx_fifo_written -= ret;
+        memmove(s->tx_fifo, s->tx_fifo + ret, s->tx_fifo_written);
+    }
+
+    // If there are still elements in the fifo, try to retransmit
+    if (s->tx_fifo_written) {
+        guint r = qemu_chr_fe_add_watch(&s->chr, G_IO_OUT | G_IO_HUP,
+                                        lpuart_transmit, s);
+        if (!r) {
+            s->tx_fifo_written = 0;
+            return G_SOURCE_REMOVE;
+        }
+    } else {
+        // There are no more elements in the fifo
+        // Transmission ended
+        s->stat |= R_STAT_TC_MASK;
+        // Fifo empty
+        s->fifo |= R_FIFO_TXEMPT_MASK;
+    }
+
+    lpuart_update_watermark(s);
+    lpuart_update_irq(s);
+
+    return G_SOURCE_REMOVE;
+}
+
+static void lpuart_write_tx_fifo(S32K358LPUART *s) {
+    // if the transmitter is not enabled, return
+    if (!(s->ctrl & R_CTRL_TE_MASK)) {
+        return;
+    }
+
+    // if the fifo is full, return and set the fifo overflow flag
+    if (s->tx_fifo_written == s->tx_fifo_size) {
+        s->fifo |= R_FIFO_TXOF_MASK;
+        lpuart_update_irq(s);
+        qemu_log_mask(LOG_GUEST_ERROR, "s32k358 lpuart: TxFIFO full");
+        return;
+    }
+
+    // Transmitting
+    s->stat &= ~R_STAT_TC_MASK;
+    // The fifo is no more empty
+    s->fifo &= ~R_FIFO_TXEMPT_MASK;
+
+    uint8_t msg = s->data & R_DATA_R07T07_MASK;
+
+    // Write the data into the fifo
+    memcpy(s->tx_fifo + s->tx_fifo_written, &msg, 1);
+    s->tx_fifo_written += 1;
+
+    lpuart_update_watermark(s);
+    lpuart_update_irq(s);
+    // Transmit
+    lpuart_transmit(NULL, G_IO_OUT, s);
+}
+
+static void lpuart_write(void *opaque, hwaddr offset, uint64_t value,
+                       unsigned size)
+{
+    S32K358LPUART *s = S32K358_LPUART(opaque);
+    uint8_t osr;
+
+    if (s->global & R_GLOBAL_RST_MASK) {
+                qemu_log_mask(LOG_GUEST_ERROR,
+                          "S32K358 LPUART: reset is active\n");
+                return;
+    }
+
+    switch (offset) {
+    case A_VERID:
+        qemu_log_mask(LOG_GUEST_ERROR,
+                          "S32K358 LPUART: VERID is a read-only register\n");
+        break;
+
+    case A_PARAM:
+        qemu_log_mask(LOG_GUEST_ERROR,
+                          "S32K358 LPUART: PARAM is a read-only register\n");
+        break;
+
+    case A_GLOBAL:
+        // setting the RST bit to 1 triggers the reset of all registers but global
+        if (value & ~R_GLOBAL_RST_MASK) {
+             qemu_log_mask(LOG_GUEST_ERROR,
+                          "S32K358 LPUART: GLOBAL reserved fields\n");
+            break;
+        }
+
+        if (value) {
+            lpuart_reset((DeviceState *)s);
+        }
+
+        s->global = value;
+        break;
+
+    case A_BAUD:
+        // Check if receiver and transmitter are disabled
+        if ((s->ctrl & R_CTRL_RE_MASK) || (s->ctrl & R_CTRL_TE_MASK)) {
+            qemu_log_mask(LOG_GUEST_ERROR,
+                          "S32K358 LPUART: to change the baud register transmitter and receiver must be disabled.\n");
+                break;
+        }
+
+        if (value & ~(R_BAUD_BOTHEDGE_MASK | R_BAUD_OSR_MASK |
+            R_BAUD_SBNS_MASK | R_BAUD_SBR_MASK)) {
+             qemu_log_mask(LOG_GUEST_ERROR,
+                          "S32K358 LPUART: BAUD unimplemented fields\n");
+            break;
+        }
+
+        osr = (value & R_BAUD_OSR_MASK) >> R_BAUD_OSR_SHIFT;
+        if (osr == 0x1 || osr == 0x2) {
+            qemu_log_mask(LOG_GUEST_ERROR,
+                          "S32K358 LPUART: OSR 0x1b and 0x10b values are reserved\n");
+            break;
+        } else if (osr >= 0x3 && osr <= 0x6) {
+            if (!(value & R_BAUD_BOTHEDGE_MASK)) {
+                qemu_log_mask(LOG_GUEST_ERROR,
+                          "S32K358 LPUART: OSR 0x3...0x06 can be set only if baud[BOTHEDGE]]=1\n");
+                break;
+            }
+        }
+
+        s->baud = value;
+
+        lpuart_update_parameters(s);
+        break;
+
+    case A_STAT:
+        if (value & (R_STAT_TC_MASK | R_STAT_TDRE_MASK | R_STAT_RDRF_MASK)) {
+            qemu_log_mask(LOG_GUEST_ERROR,
+                          "S32K358 LPUART: STAT TC, TDRE and RDRF are readonly\n");
+                break;
+        }
+        qemu_log_mask(LOG_GUEST_ERROR,
+                          "S32K358 LPUART: STAT unimplemented fields\n");
+
+        break;
+    case A_CTRL:
+        if (value & ~(R_CTRL_PT_MASK | R_CTRL_PE_MASK | R_CTRL_TE_MASK |
+            R_CTRL_RE_MASK | R_CTRL_TCIE_MASK | R_CTRL_TIE_MASK | R_CTRL_RIE_MASK)) {
+                qemu_log_mask(LOG_GUEST_ERROR,
+                          "S32K358 LPUART: CTRL unimplemented fields\n");
+                break;
+            }
+
+        s->ctrl = value;
+        lpuart_update_parameters(s);
+        lpuart_update_irq(s);
+        break;
+
+    case A_DATA:
+        if (value & ~R_DATA_R07T07_MASK) {
+            qemu_log_mask(LOG_GUEST_ERROR,
+                          "S32K358 LPUART: DATA unimplemented fields\n");
+            break;
+        }
+        s->data = value;
+        // Write the new data into the fifo, if there is enough space
+        lpuart_write_tx_fifo(s);
+        break;
+
+    case A_FIFO:
+        if (value & ~(R_FIFO_TXFLUSH_MASK | R_FIFO_RXFLUSH_MASK | R_FIFO_TXOF_MASK |
+             R_FIFO_RXUF_MASK | R_FIFO_TXFE_MASK | R_FIFO_RXFE_MASK |
+             R_FIFO_TXOFE_MASK | R_FIFO_RXUFE_MASK)) {
+                qemu_log_mask(LOG_GUEST_ERROR,
+                          "S32K358 LPUART: FIFO unimplemented or read only fields\n");
+                break;
+        }
+
+        // Check if receiver and transmitter are disabled
+        if ((s->ctrl & R_CTRL_RE_MASK) || (s->ctrl & R_CTRL_TE_MASK)) {
+            if (value & (R_FIFO_RXFE_MASK | R_FIFO_TXFE_MASK)) {
+                qemu_log_mask(LOG_GUEST_ERROR,
+                          "S32K358 LPUART: to enable/disable fifo, transmitter and receiver must be disabled.\n");
+                break;
+            }
+        }
+
+        if (value & R_FIFO_TXOF_MASK)
+            s->fifo &= ~R_FIFO_TXOF_MASK;
+        if (value & R_FIFO_RXUF_MASK)
+            s->fifo &= ~R_FIFO_RXUF_MASK;
+
+        // Flush all data inside the fifo
+        if (value & R_FIFO_RXFLUSH_MASK) {
+            s->rx_fifo_written = 0;
+            s->fifo |= R_FIFO_RXEMPT_MASK;
+            s->stat &= R_STAT_RDRF_MASK;
+        }
+        if (value & R_FIFO_TXFLUSH_MASK) {
+            s->tx_fifo_written = 0;
+            s->fifo |= R_FIFO_TXEMPT_MASK;
+            s->stat |= R_STAT_TDRE_MASK;
+        }
+
+        s->fifo &= ~(R_FIFO_TXOFE_MASK | R_FIFO_RXUFE_MASK | R_FIFO_TXFE_MASK | R_FIFO_RXFE_MASK);
+        s->fifo |= value & (R_FIFO_TXOFE_MASK | R_FIFO_RXUFE_MASK | R_FIFO_TXFE_MASK | R_FIFO_RXFE_MASK);
+
+        // Change the rx fifo dimension
+        if (value & R_FIFO_RXFE_MASK) {
+            if (s->id < 2)
+                s->rx_fifo_size = S32K358_LPUART_0_1_RX_FIFO_SIZE;
+            else
+                s->rx_fifo_size = S32K358_LPUART_2_15_RX_FIFO_SIZE;
+        } else
+            s->rx_fifo_size = 1;
+
+        // Change the tx fifo dimension
+        if (value & R_FIFO_RXFE_MASK) {
+            if (s->id < 2)
+                s->tx_fifo_size = S32K358_LPUART_0_1_TX_FIFO_SIZE;
+            else
+                s->tx_fifo_size = S32K358_LPUART_2_15_TX_FIFO_SIZE;
+        } else
+            s->tx_fifo_size = 1;
+
+        lpuart_update_irq(s);
+        break;
+
+    case A_WATER:
+        if (value & ~(R_WATER_RXWATER_MASK | R_WATER_TXWATER_MASK)) {
+            qemu_log_mask(LOG_GUEST_ERROR,
+                          "S32K358 LPUART: WATER reserved or read only fields\n");
+                break;
+        } else if ((s->id >= 2) & (value & ~(R_WATER_RXWATER_SHORT_MASK | R_WATER_TXWATER_SHORT_MASK))) {
+            qemu_log_mask(LOG_GUEST_ERROR,
+                          "S32K358 LPUART: WATER must be smaller for lpuart2...lpuart15\n");
+                break;
+        }
+        if (s->id < 2) {
+            s->tx_fifo_watermark = (value & R_WATER_TXWATER_MASK) >> R_WATER_TXWATER_SHIFT;
+            s->rx_fifo_watermark = (value & R_WATER_RXWATER_MASK) >> R_WATER_RXWATER_SHIFT;
+        } else {
+            s->tx_fifo_watermark = (value & R_WATER_TXWATER_SHORT_MASK) >> R_WATER_TXWATER_SHORT_SHIFT;
+            s->rx_fifo_watermark = (value & R_WATER_RXWATER_SHORT_MASK) >> R_WATER_RXWATER_SHORT_SHIFT;
+        }
+
+
+        lpuart_update_watermark(s);
+        break;
+
+    default:
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "S32K358 LPUART write: bad offset 0x%x\n", (int) offset);
+        break;
+    }
+}
+
+static const MemoryRegionOps lpuart_ops = {
+    .read = lpuart_read,
+    .write = lpuart_write,
+    .endianness = DEVICE_NATIVE_ENDIAN,
+};
+
+static void lpuart_init(Object *obj)
+{
+    SysBusDevice *sbd = SYS_BUS_DEVICE(obj);
+    S32K358LPUART *s = S32K358_LPUART(obj);
+
+    memory_region_init_io(&s->iomem, obj, &lpuart_ops, s, "uart", 0x0800);
+    sysbus_init_mmio(sbd, &s->iomem);
+    sysbus_init_irq(sbd, &s->uartint);
+}
+
+static void lpuart_realize(DeviceState *dev, Error **errp)
+{
+    S32K358LPUART *s = S32K358_LPUART(dev);
+
+    if (s->pclk_frq == 0) {
+        error_setg(errp, "S32K358 LPUART: pclk-frq property must be set");
+        return;
+    }
+
+    /* Flow control not implemented
+     */
+    qemu_chr_fe_set_handlers(&s->chr, lpuart_can_receive, lpuart_receive,
+                             NULL, NULL, s, NULL, true);
+}
+
+static int lpuart_post_load(void *opaque, int version_id)
+{
+    S32K358LPUART *s = S32K358_LPUART(opaque);
+
+    lpuart_update_parameters(s);
+    lpuart_update_irq(s);
+    return 0;
+}
+
+static const VMStateDescription lpuart_vmstate = {
+    .name = "s32k358-lpuart",
+    .version_id = 1,
+    .minimum_version_id = 1,
+    .post_load = lpuart_post_load,
+    .fields = (const VMStateField[]) {
+        VMSTATE_UINT32(id, S32K358LPUART),
+        VMSTATE_UINT32(verid, S32K358LPUART),
+        VMSTATE_UINT32(param, S32K358LPUART),
+        VMSTATE_UINT32(global, S32K358LPUART),
+        VMSTATE_UINT32(baud, S32K358LPUART),
+        VMSTATE_UINT32(stat, S32K358LPUART),
+        VMSTATE_UINT32(ctrl, S32K358LPUART),
+        VMSTATE_UINT32(data, S32K358LPUART),
+        VMSTATE_UINT32(fifo, S32K358LPUART),
+        VMSTATE_UINT8_ARRAY(rx_fifo, S32K358LPUART, S32K358_LPUART_0_1_RX_FIFO_SIZE),
+        VMSTATE_UINT8_ARRAY(tx_fifo, S32K358LPUART, S32K358_LPUART_0_1_TX_FIFO_SIZE),
+        VMSTATE_END_OF_LIST()
+    }
+};
+
+static Property lpuart_properties[] = {
+    DEFINE_PROP_CHR("chardev", S32K358LPUART, chr),
+    DEFINE_PROP_UINT32("pclk-frq", S32K358LPUART, pclk_frq, 0),
+    DEFINE_PROP_UINT32("id", S32K358LPUART, id, 0),
+    DEFINE_PROP_END_OF_LIST(),
+};
+
+static void lpuart_class_init(ObjectClass *klass, void *data)
+{
+    DeviceClass *dc = DEVICE_CLASS(klass);
+
+    dc->realize = lpuart_realize;
+    dc->vmsd = &lpuart_vmstate;
+    dc->reset = lpuart_reset;
+    device_class_set_props(dc, lpuart_properties);
+}
+
+static const TypeInfo lpuart_info = {
+    .name = TYPE_S32K358_LPUART,
+    .parent = TYPE_SYS_BUS_DEVICE,
+    .instance_size = sizeof(S32K358LPUART),
+    .instance_init = lpuart_init,
+    .class_init = lpuart_class_init,
+};
+
+static void lpuart_register_types(void)
+{
+    type_register_static(&lpuart_info);
+}
+
+type_init(lpuart_register_types);
diff --git a/hw/timer/Kconfig b/hw/timer/Kconfig
index 61fbb62b65..a311e189ba 100644
--- a/hw/timer/Kconfig
+++ b/hw/timer/Kconfig
@@ -56,3 +56,7 @@ config STELLARIS_GPTM
 
 config AVR_TIMER16
     bool
+
+config S32K358_TIMER
+    bool
+    select PTIMER
diff --git a/hw/timer/meson.build b/hw/timer/meson.build
index 80427852e0..45b85dbdf6 100644
--- a/hw/timer/meson.build
+++ b/hw/timer/meson.build
@@ -37,3 +37,4 @@ specific_ss.add(when: 'CONFIG_IBEX', if_true: files('ibex_timer.c'))
 system_ss.add(when: 'CONFIG_SIFIVE_PWM', if_true: files('sifive_pwm.c'))
 
 specific_ss.add(when: 'CONFIG_AVR_TIMER16', if_true: files('avr_timer16.c'))
+specific_ss.add(when: 'CONFIG_S32K358_TIMER', if_true: files('s32k358_timer.c'))
diff --git a/hw/timer/s32k358_timer.c b/hw/timer/s32k358_timer.c
new file mode 100644
index 0000000000..2cf284a788
--- /dev/null
+++ b/hw/timer/s32k358_timer.c
@@ -0,0 +1,365 @@
+/*
+ *  s32k358 PIT timer emulation
+ *
+ * SPDX-License-Identifier: CC-BY-NC-4.0
+ * Copyright (c) 2025 Braidotti Sara, Iorio Chiara, Pani Matteo.
+ *
+ */
+
+#include "qemu/osdep.h"
+#include "qemu/log.h"
+#include "qemu/module.h"
+#include "qapi/error.h"
+#include "trace.h"
+#include "hw/sysbus.h"
+#include "hw/irq.h"
+#include "hw/registerfields.h"
+#include "hw/qdev-clock.h"
+#include "hw/timer/s32k358_timer.h"
+#include "migration/vmstate.h"
+
+// Timer's registers: page 2816 manual
+// PIT module control: enables the PIT timer clocks and specifies the behaviour of the timers when PIT enters Debug mode
+REG32(MCR, 0)
+    FIELD(MCR, FRZ, 0, 1) // freeze
+    FIELD(MCR, MDIS, 1, 1) // module disable
+    FIELD(MCR, MDIS_RTI, 2, 1) // module disable RTI
+
+// The RIT and the chaining are not modeled, so we do not create the relative registers
+
+// Timer load value (specifies the length of the timeout peiod in clock cycles)
+REG32(LDVAL0, 0x100)
+REG32(LDVAL1, 0x110)
+REG32(LDVAL2, 0x120)
+REG32(LDVAL3, 0x130)
+
+// Current timer value (indicates the current timer value)
+REG32(CVAL0, 0x104)
+REG32(CVAL1, 0x114)
+REG32(CVAL2, 0x124)
+REG32(CVAL3, 0x134)
+
+// Timer control (controls timer behaviour)
+REG32(TCTRL0, 0x108)
+    FIELD(TCTRL0, TEN, 0, 1) // timer enable
+    FIELD(TCTRL0, TIE, 1, 1) // timer interrupt enable
+    FIELD(TCTRL0, CHN, 2, 1) // chain mode
+REG32(TCTRL1, 0x118)
+    FIELD(TCTRL1, TEN, 0, 1)
+    FIELD(TCTRL1, TIE, 1, 1)
+    FIELD(TCTRL1, CHN, 2, 1)
+REG32(TCTRL2, 0x128)
+    FIELD(TCTRL2, TEN, 0, 1)
+    FIELD(TCTRL2, TIE, 1, 1)
+    FIELD(TCTRL2, CHN, 2, 1)
+REG32(TCTRL3, 0x138)
+    FIELD(TCTRL3, TEN, 0, 1)
+    FIELD(TCTRL3, TIE, 1, 1)
+    FIELD(TCTRL3, CHN, 2, 1)
+
+// Timer flag (indicates the PIT had expired)
+REG32(TFLG0, 0x10C)
+    FIELD(TFLG0, TIF, 0, 1) // timer interrupt flag
+REG32(TFLG1, 0x11C)
+    FIELD(TFLG1, TIF, 0, 1)
+REG32(TFLG2, 0x12C)
+    FIELD(TFLG2, TIF, 0, 1)
+REG32(TFLG3, 0x13C)
+    FIELD(TFLG3, TIF, 0, 1)
+
+static void s32k358_irq_update(S32K358Timer *s)
+{
+    // check if timer is enabled (0 = enabled)
+    if ((s->timer_ctrl & R_MCR_MDIS_MASK)) {
+        // since it is not, clear the interrupt
+        qemu_irq_lower(s->timer_irq);
+        return;
+    }
+
+    // If at least one timer is enabled, has interrupts enabled and the timer interrupt flag set, raise the interrupt
+    for (int i = 0; i < ARRAY_SIZE(s->timers); i++) {
+        if ((s->timers[i].ctrl & R_TCTRL0_TEN_MASK) &&
+             (s->timers[i].ctrl & R_TCTRL0_TIE_MASK) &&
+             (s->timers[i].flag & R_TFLG0_TIF_MASK)) {
+                qemu_irq_raise(s->timer_irq);
+                return;
+        }
+    }
+
+    // clear the interrupt
+    qemu_irq_lower(s->timer_irq);
+}
+
+// Function that allows to read the registers' values
+static uint64_t s32k358_timer_read(void *opaque, hwaddr offset, unsigned size)
+{
+    S32K358Timer *s = S32K358_TIMER(opaque);
+    uint64_t r;
+
+    switch (offset) {
+        // Pit Module Control (MCR)
+        case A_MCR:
+            r = s->timer_ctrl;
+            break;
+        // Timer Control (TCTRL0, TCTRL1, TCTRL2, TCTRL3)
+        case A_TCTRL0:
+        case A_TCTRL1:
+        case A_TCTRL2:
+        case A_TCTRL3:
+            r = s->timers[(offset-A_TCTRL0) / (A_TCTRL1-A_TCTRL0)].ctrl;
+            break;
+        // Current Timer Value (CVAL0, CVAL1, CVAL2, CVAL3)
+        case A_CVAL0:
+        case A_CVAL1:
+        case A_CVAL2:
+        case A_CVAL3:
+            r = ptimer_get_count(s->timers[(offset-A_CVAL0) / (A_CVAL1-A_CVAL0)].timer);
+            break;
+        // Timer Load Value (LDVAL0, LDVAL1, LDVAL2, LDVAL3)
+        case A_LDVAL0:
+        case A_LDVAL1:
+        case A_LDVAL2:
+        case A_LDVAL3:
+            r = ptimer_get_limit(s->timers[(offset-A_LDVAL0) / (A_LDVAL1-A_LDVAL0)].timer);
+            break;
+        // Timer Flag (TFLG0, TFLG1, TFLG2, TFLG3)
+        case A_TFLG0:
+        case A_TFLG1:
+        case A_TFLG2:
+        case A_TFLG3:
+            r = s->timers[(offset-A_TFLG0) / (A_TFLG1-A_TFLG0)].flag;
+            break;
+        default: {
+            qemu_log_mask(LOG_GUEST_ERROR,
+                        "CMSDK APB timer read: bad offset %x\n", (int) offset);
+            r = 0;
+            break;
+        }
+    }
+
+    return r;
+}
+
+// To switch on/off the timer (since it may be enabled/disabled through the s32k358_timer_write funtion)
+static void s32k358_timer_switch_on_off(S32K358Timer *s, uint32_t idx) {
+    ptimer_transaction_begin(s->timers[idx].timer);
+    if ((s->timers[idx].ctrl & R_TCTRL0_TEN_MASK) && !(s->timer_ctrl & R_MCR_MDIS_MASK)) {
+        ptimer_run(s->timers[idx].timer, 0 /* reloadable timer */);
+    } else {
+        ptimer_stop(s->timers[idx].timer);
+    }
+    ptimer_transaction_commit(s->timers[idx].timer);
+}
+
+static void s32k358_timer_write(void *opaque, hwaddr offset, uint64_t value,
+                                  unsigned size)
+{
+    S32K358Timer *s = S32K358_TIMER(opaque);
+    uint32_t idx;
+
+    switch (offset) {
+    // Pit Module Control (MCR)
+    case R_MCR:
+        // Write the first 3 bits, the others are reserved
+        s->timer_ctrl = value & (R_MCR_FRZ_MASK | R_MCR_MDIS_MASK | R_MCR_MDIS_RTI_MASK);
+        // Changing the FRZ and the RTI will have no effect
+        if (value & (R_MCR_FRZ_MASK | R_MCR_MDIS_RTI_MASK)) {
+            // We don't model this.
+            qemu_log_mask(LOG_UNIMP,
+                          "S32K358 timer: FRZ and MDIS_RTI input not supported\n");
+        }
+
+        // If enable the PIT, reset the four timers
+        for (idx = 0; idx < ARRAY_SIZE(s->timers); idx++)
+            s32k358_timer_switch_on_off(s, idx);
+
+        break;
+    // Timer Control (TCTRL0, TCTRL1, TCTRL2, TCTRL3)
+    case A_TCTRL0:
+    case A_TCTRL1:
+    case A_TCTRL2:
+    case A_TCTRL3:
+        // derive the channel
+        idx = (offset-A_TCTRL0) / (A_TCTRL1-A_TCTRL0);
+        // modify only the last three bits, the others are reserved
+        s->timers[idx].ctrl = value & (R_TCTRL0_CHN_MASK | R_TCTRL0_TEN_MASK | R_TCTRL0_TIE_MASK);
+        // Changing the CHN will have no effect
+        if (value & R_TCTRL0_CHN_MASK) {
+            // We don't model this.
+            qemu_log_mask(LOG_UNIMP,
+                          "S32K358 timer: CHN input not supported\n");
+        }
+
+        // if TIF is enabled, changing the timer interrupt enable triggers an interupt (manual - page 2830)
+        s32k358_irq_update(s);
+        // If enable the timer, reset it
+        s32k358_timer_switch_on_off(s, idx);
+
+        break;
+    // Timer Flag (TFLG0, TFLG1, TFLG2, TFLG3)
+    case A_TFLG0:
+    case A_TFLG1:
+    case A_TFLG2:
+    case A_TFLG3:
+        value &= R_TFLG0_TIF_MASK;
+        s->timers[(offset-A_TFLG0) / (A_TFLG1-A_TFLG0)].flag &= ~value;
+        // if TIF=1, it may have to trigger the interrupt
+        s32k358_irq_update(s);
+        break;
+     // Timer Load Value (LDVAL0, LDVAL1, LDVAL2, LDVAL3)
+    case A_LDVAL0:
+    case A_LDVAL1:
+    case A_LDVAL2:
+    case A_LDVAL3:
+        idx = (offset-A_LDVAL0) / (A_LDVAL1-A_LDVAL0);
+
+        ptimer_transaction_begin(s->timers[idx].timer);
+        // Do not reload immediately the timer, wait that it expires before loading the new value
+        // Hence, change the reload value but not the CVAL one
+        ptimer_set_limit(s->timers[idx].timer, value, 0);
+        // Check if the pit and line of the timer are enabled
+        // R_TCTRL0_TEN_MASK is the same for all the registers
+        if (!(s->timer_ctrl & R_MCR_MDIS_MASK) && (s->timers[idx].ctrl & R_TCTRL0_TEN_MASK)) {
+            // Make sure timer is running (it doesn't reset it if it was already)
+            ptimer_run(s->timers[idx].timer, 0 /* reloadable timer */);
+        }
+        ptimer_transaction_commit(s->timers[idx].timer);
+        break;
+    // Current Timer Value (CVAL0, CVAL1, CVAL2, CVAL3)
+    case A_CVAL0:
+    case A_CVAL1:
+    case A_CVAL2:
+    case A_CVAL3:
+        // It is a read-only register
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "S32K358 timer write: write to Read-Only offset 0x%x\n",
+                      (int)offset);
+        break;
+
+    default:
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "S32K358 timer write: bad offset 0x%x\n", (int) offset);
+        break;
+    }
+}
+
+static const MemoryRegionOps s32k358_timer_ops = {
+    .read = s32k358_timer_read,
+    .write = s32k358_timer_write,
+    .endianness = DEVICE_NATIVE_ENDIAN,
+};
+
+// Function called when the timer expires
+static void s32k358_timer_tick(void *opaque)
+{
+    struct sub_timer *st = (struct sub_timer*)opaque;
+
+    // set interrupt flag (always)
+    st->flag |= R_TFLG0_TIF_MASK;
+    // if interrupts are enabled trigger interrupt
+    if (st->ctrl & R_TCTRL0_TIE_MASK) {
+        qemu_irq_raise(st->parent->timer_irq);
+    }
+}
+
+static void s32k358_timer_reset(DeviceState *dev)
+{
+    S32K358Timer *s = S32K358_TIMER(dev);
+
+    for (int i = 0; i < ARRAY_SIZE(s->timers); i++) {
+        /* Set the ctrl and tif */
+        s->timers[i].ctrl = 0;
+        s->timers[i].flag = 0;
+        ptimer_transaction_begin(s->timers[i].timer);
+        ptimer_stop(s->timers[i].timer);
+        /* Set the limit */
+        ptimer_set_limit(s->timers[i].timer, 0, 1);
+        ptimer_transaction_commit(s->timers[i].timer);
+    }
+}
+
+// Model the timer increment
+static void s32k358_timer_clk_update(void *opaque, ClockEvent event)
+{
+    S32K358Timer *s = S32K358_TIMER(opaque);
+    for (int i = 0; i < ARRAY_SIZE(s->timers); i++) {
+        ptimer_transaction_begin(s->timers[i].timer);
+        ptimer_set_period_from_clock(s->timers[i].timer, s->pclk, 1);
+        ptimer_transaction_commit(s->timers[i].timer);
+    }
+}
+
+static void s32k358_timer_init(Object *obj)
+{
+    SysBusDevice *sbd = SYS_BUS_DEVICE(obj);
+    S32K358Timer *s = S32K358_TIMER(obj);
+
+    // Create the memory region in which the timers are memory-mapped
+    memory_region_init_io(&s->iomem, obj, &s32k358_timer_ops,
+                          s, "s32k358-timer", 0x140);
+    sysbus_init_mmio(sbd, &s->iomem);
+    // Connect the irq line and clock
+    sysbus_init_irq(sbd, &s->timer_irq);
+    s->pclk = qdev_init_clock_in(DEVICE(s), "pclk",
+                                 s32k358_timer_clk_update, s, ClockUpdate);
+}
+
+static void s32k358_timer_realize(DeviceState *dev, Error **errp)
+{
+    S32K358Timer *s = S32K358_TIMER(dev);
+
+    if (!clock_has_source(s->pclk)) {
+        error_setg(errp, "S32K358 timer: pclk clock must be connected");
+        return;
+    }
+
+    for (int i = 0; i < ARRAY_SIZE(s -> timers); i++) {
+        s->timers[i].parent = s;
+        // Init the four channels
+        s->timers[i].timer = ptimer_init(s32k358_timer_tick, &(s->timers[i]),
+                           PTIMER_POLICY_WRAP_AFTER_ONE_PERIOD |
+                           PTIMER_POLICY_TRIGGER_ONLY_ON_DECREMENT |
+                           PTIMER_POLICY_NO_IMMEDIATE_RELOAD |
+                           PTIMER_POLICY_NO_COUNTER_ROUND_DOWN);
+
+        ptimer_transaction_begin(s->timers[i].timer);
+        ptimer_set_period_from_clock(s->timers[i].timer, s->pclk, 1);
+        ptimer_transaction_commit(s->timers[i].timer);
+    }
+}
+
+static const VMStateDescription s32k358_timer_vmstate = {
+    .name = "s32k358-timer",
+    .version_id = 2,
+    .minimum_version_id = 2,
+    // only public field, irq and pclk
+    .fields = (const VMStateField[]) {
+        VMSTATE_CLOCK(pclk, S32K358Timer),
+        VMSTATE_END_OF_LIST()
+    }
+};
+
+static void s32k358_timer_class_init(ObjectClass *klass, void *data)
+{
+    DeviceClass *dc = DEVICE_CLASS(klass);
+
+    dc->realize = s32k358_timer_realize;
+    dc->vmsd = &s32k358_timer_vmstate;
+    dc->reset = s32k358_timer_reset;
+}
+
+static const TypeInfo s32k358_timer_info = {
+    .name = TYPE_S32K358_TIMER,
+    .parent = TYPE_SYS_BUS_DEVICE,
+    .instance_size = sizeof(S32K358Timer),
+    .instance_init = s32k358_timer_init,
+    .class_init = s32k358_timer_class_init,
+};
+
+static void s32k358_timer_register_types(void)
+{
+    type_register_static(&s32k358_timer_info);
+}
+
+type_init(s32k358_timer_register_types);
+
diff --git a/include/hw/char/s32k358_uart.h b/include/hw/char/s32k358_uart.h
new file mode 100644
index 0000000000..90297b4a6d
--- /dev/null
+++ b/include/hw/char/s32k358_uart.h
@@ -0,0 +1,58 @@
+/*
+ * S32K358 LPUART emulation
+ *
+ * SPDX-License-Identifier: CC-BY-NC-4.0
+ * Copyright (c) 2025 Braidotti Sara, Iorio Chiara, Pani Matteo.
+ *
+ */
+
+#ifndef S32K358_UART_H
+#define S32K358_UART_H
+
+#include "hw/sysbus.h"
+#include "chardev/char-fe.h"
+#include "qom/object.h"
+
+#define TYPE_S32K358_LPUART "s32k358_lpuart"
+OBJECT_DECLARE_SIMPLE_TYPE(S32K358LPUART, S32K358_LPUART)
+
+#define S32K358_LPUART_0_1_RX_FIFO_SIZE           16
+#define S32K358_LPUART_0_1_TX_FIFO_SIZE           16
+#define S32K358_LPUART_2_15_RX_FIFO_SIZE           4
+#define S32K358_LPUART_2_15_TX_FIFO_SIZE           4
+
+struct S32K358LPUART {
+    /*< private >*/
+    SysBusDevice parent_obj;
+
+    /*< public >*/
+    MemoryRegion iomem;
+    CharBackend chr;
+    qemu_irq uartint;
+    guint watch_tag;
+
+    uint32_t id;
+    uint32_t verid;
+    uint32_t param;
+    uint32_t pclk_frq;
+    uint32_t baud;
+    uint32_t global;
+    uint32_t stat;
+    uint32_t ctrl;
+    uint32_t data;
+    uint32_t fifo;
+    uint32_t txcnt;
+    uint32_t rxcnt;
+
+    /* This UART has a FIFO */
+    uint8_t rx_fifo[S32K358_LPUART_0_1_RX_FIFO_SIZE];
+    uint8_t tx_fifo[S32K358_LPUART_0_1_TX_FIFO_SIZE];
+    uint8_t tx_fifo_size;
+    uint8_t rx_fifo_size;
+    uint8_t tx_fifo_written;
+    uint8_t rx_fifo_written;
+    uint8_t tx_fifo_watermark;
+    uint8_t rx_fifo_watermark;
+};
+
+#endif
diff --git a/include/hw/timer/s32k358_timer.h b/include/hw/timer/s32k358_timer.h
new file mode 100644
index 0000000000..eb7c8b0a08
--- /dev/null
+++ b/include/hw/timer/s32k358_timer.h
@@ -0,0 +1,52 @@
+/*
+ *  s32k358 PIT timer emulation
+ *
+ * SPDX-License-Identifier: CC-BY-NC-4.0
+ * Copyright (c) 2025 Braidotti Sara, Iorio Chiara, Pani Matteo.
+ *
+ */
+
+#ifndef S32K358_TIMER_H
+#define S32K358_TIMER_H
+
+#include "hw/sysbus.h"
+#include "hw/ptimer.h"
+#include "hw/clock.h"
+#include "qom/object.h"
+
+#define TYPE_S32K358_TIMER "s32k358-timer"
+OBJECT_DECLARE_SIMPLE_TYPE(S32K358Timer, S32K358_TIMER)
+
+/*
+ * QEMU interface:
+ *  + Clock input "pclk": clock for the timer
+ *  + sysbus MMIO region 0: the register bank
+ *  + sysbus IRQ 0: timer interrupt
+ */
+
+struct S32K358Timer;
+
+// Data structure representing each timer's channel
+struct sub_timer {
+    struct S32K358Timer *parent;
+    struct ptimer_state *timer;
+    uint32_t ctrl;
+    uint32_t flag;
+};
+
+// Data structure representing the PIT (periodic interrupt timer)
+struct S32K358Timer {
+    /*< private >*/
+    SysBusDevice parent_obj;
+
+    /*< public >*/
+    MemoryRegion iomem;
+    qemu_irq timer_irq;
+
+    Clock *pclk;
+    uint32_t timer_ctrl;
+    struct sub_timer timers[4]; // the timer has 4 channels
+};
+
+#endif
+
