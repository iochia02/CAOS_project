diff --git a/configs/devices/arm-softmmu/default.mak b/configs/devices/arm-softmmu/default.mak
index 31f77c2026..096d5ee246 100644
--- a/configs/devices/arm-softmmu/default.mak
+++ b/configs/devices/arm-softmmu/default.mak
@@ -49,3 +49,5 @@
 # CONFIG_FSL_IMX7=n
 # CONFIG_FSL_IMX6UL=n
 # CONFIG_ALLWINNER_H3=n
+
+CONFIG_S32K358=y
diff --git a/hw/arm/Kconfig b/hw/arm/Kconfig
index 1ad60da7aa..75c9b79428 100644
--- a/hw/arm/Kconfig
+++ b/hw/arm/Kconfig
@@ -712,3 +712,16 @@ config ARMSSE
     select UNIMP
     select SSE_COUNTER
     select SSE_TIMER
+
+config S32K358
+    bool
+    default y
+    depends on TCG && ARM
+    select ARMSSE
+    select MPS2_SCC
+    select OR_IRQ
+    select PL022    # SPI
+    select PL080    # DMA controller
+    select SPLIT_IRQ
+    select UNIMP
+    select CMSDK_APB_WATCHDOG
diff --git a/hw/arm/meson.build b/hw/arm/meson.build
index 0c07ab522f..ea82ee5967 100644
--- a/hw/arm/meson.build
+++ b/hw/arm/meson.build
@@ -78,4 +78,6 @@ system_ss.add(when: 'CONFIG_VERSATILE', if_true: files('versatilepb.c'))
 system_ss.add(when: 'CONFIG_VEXPRESS', if_true: files('vexpress.c'))
 system_ss.add(when: 'CONFIG_Z2', if_true: files('z2.c'))
 
+arm_ss.add(when: 'CONFIG_S32K358', if_true: files('s32k358.c'))
+
 hw_arch += {'arm': arm_ss}
diff --git a/hw/arm/s32k358.c b/hw/arm/s32k358.c
new file mode 100644
index 0000000000..f2851bbab2
--- /dev/null
+++ b/hw/arm/s32k358.c
@@ -0,0 +1,257 @@
+/*
+ * ARM s32k358 board emulation.
+ *
+ * Copyright (c) 2017 Linaro Limited
+ * Written by Peter Maydell
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 or
+ *  (at your option) any later version.
+ */
+
+#include "qemu/osdep.h" // Pull in some common system headers that most code in QEMU will want
+#include "qemu/units.h" // Simply defines KiB, MiB
+#include "qemu/cutils.h" // Defines some function about strings
+#include "qapi/error.h" // Error reporting system loosely patterned after Glib's GError.
+#include "qemu/error-report.h" // error reporting
+#include "hw/arm/boot.h" // ARM kernel loader.
+#include "hw/arm/armv7m.h" // ARMv7M CPU object
+#include "hw/or-irq.h" // for interrupt reqest
+#include "hw/boards.h" //  Declarations for use by board files for creating devices (e.g machine_type_name)
+#include "exec/address-spaces.h" //  Internal memory management interfaces
+#include "sysemu/sysemu.h" // Misc. things related to the system emulator.
+#include "hw/qdev-properties.h" // Define device properties
+#include "hw/misc/unimp.h" // create_unimplemented_device
+#include "hw/char/cmsdk-apb-uart.h" // This is a model of the "APB UART" which is part of the Cortex-M System Design Kit
+#include "hw/timer/cmsdk-apb-timer.h" // This is a model of the "APB timer" which is part of the Cortex-M System Design Kit
+#include "hw/timer/cmsdk-apb-dualtimer.h" // This is a model of the "APB dual-input timer" which is part of the Cortex-M System Design Kit
+#include "hw/misc/mps2-scc.h" // ARM MPS2 SCC emulation
+#include "hw/misc/mps2-fpgaio.h" // ARM MPS2 FPGAIO emulation
+#include "hw/ssi/pl022.h" // Arm PrimeCell PL022 Synchronous Serial Port
+#include "hw/i2c/arm_sbcon_i2c.h" // ARM Versatile I2C controller
+#include "hw/net/lan9118.h" // SMSC LAN9118 Ethernet interface emulation
+#include "net/net.h" // Net configurations (clients, sockets,...)
+#include "hw/watchdog/cmsdk-apb-watchdog.h" // This is a model of the "APB watchdog" which is part of the Cortex-M System Design Kit
+#include "hw/qdev-clock.h" // Device's clock input and output
+#include "qapi/qmp/qlist.h" // QList Module (provides dynamic arrays)
+#include "qom/object.h" // QEMU Object Model
+
+// Data types representing our machine
+struct S32K358MachineClass {
+    MachineClass parent;
+};
+
+struct S32K358MachineState {
+    MachineState parent;
+    ARMv7MState armv7m; // CPU
+    MemoryRegion utest;
+    MemoryRegion cflash0; // Code flash
+    MemoryRegion cflash1;
+    MemoryRegion cflash2;
+    MemoryRegion cflash3;
+    MemoryRegion dflash0; // Data flash
+    MemoryRegion itcm0; // memory located in 0x0, here we put the interrupt vector table
+    MemoryRegion dtcm0;
+    MemoryRegion sram0; // RAM
+    MemoryRegion sram1;
+    MemoryRegion sram2;
+    /*
+     * When we'll have timers we adapt and decomment it
+     * CMSDKAPBDualTimer dualtimer;
+     * CMSDKAPBWatchdog watchdog;
+     * CMSDKAPBTimer timer[2];
+    */
+    Clock *sysclk; // Clock
+    Clock *refclk;
+};
+
+#define TYPE_S32K358_MACHINE MACHINE_TYPE_NAME("s32k358")
+
+OBJECT_DECLARE_TYPE(S32K358MachineState, S32K358MachineClass, S32K358_MACHINE)
+
+
+/* Main SYSCLK frequency in Hz */
+/* Accordimg to the documentation, it can run up to 240 MHz */
+/* We found this value in the offical freeRTOS demo for s32k3x8 */
+#define SYSCLK_FRQ 24000000
+
+/*
+ * The Application Notes don't say anything about how the
+ * systick reference clock is configured. (Quite possibly
+ * they don't have one at all.) This 1MHz clock matches the
+ * pre-existing behaviour that used to be hardcoded in the
+ * armv7m_systick implementation.
+ */
+#define REFCLK_FRQ (1 * 1000 * 1000)
+
+/* Initialize the auxiliary RAM region @mr and map it into
+ * the memory map at @base.
+ */
+static void make_ram(MemoryRegion *system_memory, MemoryRegion *mr,
+                     const char *name, hwaddr base, hwaddr size)
+{
+    memory_region_init_ram(mr, NULL, name, size, &error_fatal);
+    memory_region_add_subregion(system_memory, base, mr);
+}
+
+static void s32k358_init(MachineState *machine)
+{
+    S32K358MachineState *mms = S32K358_MACHINE(machine);
+    MemoryRegion *system_memory = get_system_memory();
+    DeviceState *armv7m;
+    int i;
+
+    /* This clock doesn't need migration because it is fixed-frequency */
+    mms->sysclk = clock_new(OBJECT(machine), "SYSCLK");
+    clock_set_hz(mms->sysclk, SYSCLK_FRQ);
+
+    mms->refclk = clock_new(OBJECT(machine), "REFCLK");
+    clock_set_hz(mms->refclk, REFCLK_FRQ);
+
+    /*
+     * Memory regions on the system
+     * We need to define the base address and the size of each memory space
+     * Refer to pages 3 (Flash memories) and 13 (RAM memories) of the S32K3 Memories Guide
+     * Create the memory region, add it to the memory regions of the system and finally link it to the CPU
+    */
+
+    make_ram(system_memory, &mms->itcm0, "s32k358.itcm0", 0x00000000, 0x10000);
+    make_ram(system_memory, &mms->cflash0, "s32k358.cflash0", 0x00400000, 0x200000);
+    make_ram(system_memory, &mms->cflash1, "s32k358.cflash1", 0x00600000, 0x200000);
+    make_ram(system_memory, &mms->cflash2, "s32k358.cflash2", 0x00800000, 0x200000);
+    make_ram(system_memory, &mms->cflash3, "s32k358.cflash3", 0x00A00000, 0x200000);
+    make_ram(system_memory, &mms->dflash0, "s32k358.dflash0", 0x10000000, 0x20000);
+    make_ram(system_memory, &mms->dtcm0, "s32k358.dtcm0", 0x20000000, 0x20000);
+    make_ram(system_memory, &mms->utest, "s32k358.utest", 0x1B000000, 0x2000);
+    make_ram(system_memory, &mms->sram0, "s32k358.sram0", 0x20400000, 0x40000);
+    make_ram(system_memory, &mms->sram1, "s32k358.sram1", 0x20440000, 0x40000);
+    make_ram(system_memory, &mms->sram2, "s32k358.sram2", 0x20480000, 0x40000);
+
+    // CPU: arm-cortex-m7
+    object_initialize_child(OBJECT(mms), "armv7m", &mms->armv7m, TYPE_ARMV7M);
+    armv7m = DEVICE(&mms->armv7m);
+    // Number of interrupts (see interrupt map)
+    qdev_prop_set_uint32(armv7m, "num-irq", 240);
+
+    qdev_connect_clock_in(armv7m, "cpuclk", mms->sysclk);
+    qdev_connect_clock_in(armv7m, "refclk", mms->refclk);
+    qdev_prop_set_string(armv7m, "cpu-type", machine->cpu_type);
+    qdev_prop_set_bit(armv7m, "enable-bitband", true);
+    object_property_set_link(OBJECT(&mms->armv7m), "memory",
+                             OBJECT(system_memory), &error_abort);
+    sysbus_realize(SYS_BUS_DEVICE(&mms->armv7m), &error_fatal);
+
+
+    /* The overflow IRQs for UARTs 0, 1 and 2 are ORed together.
+    * Overflow for UARTs 4 and 5 doesn't trigger any interrupt.
+    */
+
+    // This is the logic used to implement this type of uart
+    // Probably we won't need it
+    Object *orgate;
+    DeviceState *orgate_dev;
+
+    orgate = object_new(TYPE_OR_IRQ);
+    object_property_set_int(orgate, "num-lines", 6, &error_fatal);
+    qdev_realize(DEVICE(orgate), NULL, &error_fatal);
+    orgate_dev = DEVICE(orgate);
+    qdev_connect_gpio_out(orgate_dev, 0, qdev_get_gpio_in(armv7m, 12));
+
+    for (i = 0; i < 4; i++) {
+        DeviceState *dev;
+        SysBusDevice *s;
+
+        // This addresses and irq are correct, but we should implement the right type of uart
+        static const hwaddr uartbase[] = {0x40328000, 0x4032C000,
+                                            0x40330000, 0x40334000
+                                            };
+        static const int uartirq[] = {141, 142, 143, 144};
+        qemu_irq txovrint = NULL, rxovrint = NULL;
+
+        if (i < 3) {
+            txovrint = qdev_get_gpio_in(orgate_dev, i * 2);
+            rxovrint = qdev_get_gpio_in(orgate_dev, i * 2 + 1);
+        }
+
+        dev = qdev_new(TYPE_CMSDK_APB_UART);
+        s = SYS_BUS_DEVICE(dev);
+        qdev_prop_set_chr(dev, "chardev", serial_hd(i));
+        qdev_prop_set_uint32(dev, "pclk-frq", SYSCLK_FRQ);
+        sysbus_realize_and_unref(s, &error_fatal);
+        sysbus_mmio_map(s, 0, uartbase[i]);
+        sysbus_connect_irq(s, 0, qdev_get_gpio_in(armv7m, uartirq[i]));
+        sysbus_connect_irq(s, 1, qdev_get_gpio_in(armv7m, uartirq[i]));
+        sysbus_connect_irq(s, 2, txovrint);
+        sysbus_connect_irq(s, 3, rxovrint);
+    }
+
+    /*for (i = 0; i < 4; i++) {
+        static const hwaddr gpiobase[] = {0x40010000, 0x40011000,
+                                          0x40012000, 0x40013000};
+        create_unimplemented_device("cmsdk-ahb-gpio", gpiobase[i], 0x1000);
+    }
+*/
+    // Timers we'll be implemented here
+    /* CMSDK APB subsystem
+    for (i = 0; i < ARRAY_SIZE(mms->timer); i++) {
+        g_autofree char *name = g_strdup_printf("timer%d", i);
+        hwaddr base = 0x40000000 + i * 0x1000;
+        int irqno = 8 + i;
+        SysBusDevice *sbd;
+
+        object_initialize_child(OBJECT(mms), name, &mms->timer[i],
+                                TYPE_CMSDK_APB_TIMER);
+        sbd = SYS_BUS_DEVICE(&mms->timer[i]);
+        qdev_connect_clock_in(DEVICE(&mms->timer[i]), "pclk", mms->sysclk);
+        sysbus_realize_and_unref(sbd, &error_fatal);
+        sysbus_mmio_map(sbd, 0, base);
+        sysbus_connect_irq(sbd, 0, qdev_get_gpio_in(armv7m, irqno));
+    }
+
+    object_initialize_child(OBJECT(mms), "dualtimer", &mms->dualtimer,
+                            TYPE_CMSDK_APB_DUALTIMER);
+    qdev_connect_clock_in(DEVICE(&mms->dualtimer), "TIMCLK", mms->sysclk);
+    sysbus_realize(SYS_BUS_DEVICE(&mms->dualtimer), &error_fatal);
+    sysbus_connect_irq(SYS_BUS_DEVICE(&mms->dualtimer), 0,
+                       qdev_get_gpio_in(armv7m, 10));
+    sysbus_mmio_map(SYS_BUS_DEVICE(&mms->dualtimer), 0, 0x40002000);
+    object_initialize_child(OBJECT(mms), "watchdog", &mms->watchdog,
+                            TYPE_CMSDK_APB_WATCHDOG);
+    qdev_connect_clock_in(DEVICE(&mms->watchdog), "WDOGCLK", mms->sysclk);
+    sysbus_realize(SYS_BUS_DEVICE(&mms->watchdog), &error_fatal);
+    sysbus_connect_irq(SYS_BUS_DEVICE(&mms->watchdog), 0,
+                       qdev_get_gpio_in_named(armv7m, "NMI", 0));
+    sysbus_mmio_map(SYS_BUS_DEVICE(&mms->watchdog), 0, 0x40008000);*/
+
+    // Address from which load the kernel
+    // The address specified here is usually not used
+    // (only if it's not specified in the elf file)
+    armv7m_load_kernel(ARM_CPU(first_cpu), machine->kernel_filename,
+                       0x00400000, 0x200000);
+}
+
+// Machine init
+static void s32k358_class_init(ObjectClass *oc, void *data)
+{
+    MachineClass *mc = MACHINE_CLASS(oc);
+
+    mc->init = s32k358_init;
+    mc->max_cpus = 1;
+    mc->default_cpu_type = ARM_CPU_TYPE_NAME("cortex-m7");
+    mc->desc = "ARM S32K358";
+}
+
+static const TypeInfo s32k358_info = {
+    .name = TYPE_S32K358_MACHINE,
+    .parent = TYPE_MACHINE,
+    .instance_size = sizeof(S32K358MachineState),
+    .class_size = sizeof(S32K358MachineClass),
+    .class_init = s32k358_class_init,
+};
+
+static void s32k358_machine_init(void)
+{
+    type_register_static(&s32k358_info);
+}
+
+type_init(s32k358_machine_init);
