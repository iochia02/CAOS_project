diff --git a/configs/devices/arm-softmmu/default.mak b/configs/devices/arm-softmmu/default.mak
index 31f77c2026..096d5ee246 100644
--- a/configs/devices/arm-softmmu/default.mak
+++ b/configs/devices/arm-softmmu/default.mak
@@ -49,3 +49,5 @@
 # CONFIG_FSL_IMX7=n
 # CONFIG_FSL_IMX6UL=n
 # CONFIG_ALLWINNER_H3=n
+
+CONFIG_S32K358=y
diff --git a/hw/arm/Kconfig b/hw/arm/Kconfig
index 1ad60da7aa..fac618652e 100644
--- a/hw/arm/Kconfig
+++ b/hw/arm/Kconfig
@@ -712,3 +712,17 @@ config ARMSSE
     select UNIMP
     select SSE_COUNTER
     select SSE_TIMER
+
+config S32K358
+    bool
+    default y
+    depends on TCG && ARM
+    select ARMSSE
+    select MPS2_SCC
+    select OR_IRQ
+    select PL022    # SPI
+    select PL080    # DMA controller
+    select SPLIT_IRQ
+    select UNIMP
+    select S32K358_TIMER
+    select CMSDK_APB_WATCHDOG
diff --git a/hw/arm/meson.build b/hw/arm/meson.build
index 0c07ab522f..ea82ee5967 100644
--- a/hw/arm/meson.build
+++ b/hw/arm/meson.build
@@ -78,4 +78,6 @@ system_ss.add(when: 'CONFIG_VERSATILE', if_true: files('versatilepb.c'))
 system_ss.add(when: 'CONFIG_VEXPRESS', if_true: files('vexpress.c'))
 system_ss.add(when: 'CONFIG_Z2', if_true: files('z2.c'))
 
+arm_ss.add(when: 'CONFIG_S32K358', if_true: files('s32k358.c'))
+
 hw_arch += {'arm': arm_ss}
diff --git a/hw/arm/s32k358.c b/hw/arm/s32k358.c
new file mode 100644
index 0000000000..5a97c5d858
--- /dev/null
+++ b/hw/arm/s32k358.c
@@ -0,0 +1,229 @@
+/*
+ * ARM s32k358 board emulation.
+ *
+ * SPDX-License-Identifier: CC-BY-NC-4.0
+ * Copyright (c) 2025 Braidotti Sara, Iorio Chiara, Pani Matteo.
+ *
+ */
+
+#include "qemu/osdep.h" // Pull in some common system headers that most code in QEMU will want
+#include "qemu/units.h" // Simply defines KiB, MiB
+#include "qemu/cutils.h" // Defines some function about strings
+#include "qapi/error.h" // Error reporting system loosely patterned after Glib's GError.
+#include "qemu/error-report.h" // error reporting
+#include "hw/arm/boot.h" // ARM kernel loader.
+#include "hw/arm/armv7m.h" // ARMv7M CPU object
+#include "hw/or-irq.h" // for interrupt reqest
+#include "hw/boards.h" //  Declarations for use by board files for creating devices (e.g machine_type_name)
+#include "exec/address-spaces.h" //  Internal memory management interfaces
+#include "sysemu/sysemu.h" // Misc. things related to the system emulator.
+#include "hw/qdev-properties.h" // Define device properties
+#include "hw/misc/unimp.h" // create_unimplemented_device
+#include "hw/char/cmsdk-apb-uart.h" // This is a model of the "APB UART" which is part of the Cortex-M System Design Kit
+#include "hw/misc/mps2-scc.h" // ARM MPS2 SCC emulation
+#include "hw/misc/mps2-fpgaio.h" // ARM MPS2 FPGAIO emulation
+#include "hw/ssi/pl022.h" // Arm PrimeCell PL022 Synchronous Serial Port
+#include "hw/i2c/arm_sbcon_i2c.h" // ARM Versatile I2C controller
+#include "hw/net/lan9118.h" // SMSC LAN9118 Ethernet interface emulation
+#include "net/net.h" // Net configurations (clients, sockets,...)
+#include "hw/watchdog/cmsdk-apb-watchdog.h" // This is a model of the "APB watchdog" which is part of the Cortex-M System Design Kit
+#include "hw/qdev-clock.h" // Device's clock input and output
+#include "qapi/qmp/qlist.h" // QList Module (provides dynamic arrays)
+#include "qom/object.h" // QEMU Object Model
+#include "hw/timer/s32k358_timer.h"
+
+// Data types representing the machine
+struct S32K358MachineClass {
+    MachineClass parent;
+};
+
+struct S32K358MachineState {
+    MachineState parent;
+    ARMv7MState armv7m; // CPU
+    MemoryRegion utest;
+    MemoryRegion cflash0; // Code flash
+    MemoryRegion cflash1;
+    MemoryRegion cflash2;
+    MemoryRegion cflash3;
+    MemoryRegion dflash0; // Data flash
+    MemoryRegion itcm0; // memory located in 0x0, here we put the interrupt vector table
+    MemoryRegion dtcm0;
+    MemoryRegion sram0; // RAM
+    MemoryRegion sram1;
+    MemoryRegion sram2;
+    S32K358Timer timer[3];
+    Clock *sysclk; // Clock
+    Clock *refclk;
+};
+
+#define TYPE_S32K358_MACHINE MACHINE_TYPE_NAME("s32k358")
+
+OBJECT_DECLARE_TYPE(S32K358MachineState, S32K358MachineClass, S32K358_MACHINE)
+
+
+/* Main SYSCLK frequency in Hz */
+/* Accordimg to the documentation, it can run up to 240 MHz */
+/* We found this value in the offical freeRTOS demo for s32k3x8 */
+#define SYSCLK_FRQ 24000000
+
+/*
+ * The Application Notes don't say anything about how the
+ * systick reference clock is configured. (Quite possibly
+ * they don't have one at all.) This 1MHz clock matches the
+ * pre-existing behaviour that used to be hardcoded in the
+ * armv7m_systick implementation.
+ */
+#define REFCLK_FRQ (1 * 1000 * 1000)
+
+/* Initialize the auxiliary RAM region @mr and map it into
+ * the memory map at @base.
+ */
+static void make_ram(MemoryRegion *system_memory, MemoryRegion *mr,
+                     const char *name, hwaddr base, hwaddr size)
+{
+    memory_region_init_ram(mr, NULL, name, size, &error_fatal);
+    memory_region_add_subregion(system_memory, base, mr);
+}
+
+static void s32k358_init(MachineState *machine)
+{
+    S32K358MachineState *mms = S32K358_MACHINE(machine);
+    MemoryRegion *system_memory = get_system_memory();
+    DeviceState *armv7m;
+    int i;
+
+    /* This clock doesn't need migration because it is fixed-frequency */
+    mms->sysclk = clock_new(OBJECT(machine), "SYSCLK");
+    clock_set_hz(mms->sysclk, SYSCLK_FRQ);
+
+    mms->refclk = clock_new(OBJECT(machine), "REFCLK");
+    clock_set_hz(mms->refclk, REFCLK_FRQ);
+
+    /*
+     * Memory regions on the system
+     * We need to define the base address and the size of each memory space
+     * Refer to pages 3 (Flash memories) and 13 (RAM memories) of the S32K3 Memories Guide
+     * Create the memory region, add it to the memory regions of the system and finally link it to the CPU
+    */
+
+    make_ram(system_memory, &mms->itcm0, "s32k358.itcm0", 0x00000000, 0x10000);
+    make_ram(system_memory, &mms->cflash0, "s32k358.cflash0", 0x00400000, 0x200000);
+    make_ram(system_memory, &mms->cflash1, "s32k358.cflash1", 0x00600000, 0x200000);
+    make_ram(system_memory, &mms->cflash2, "s32k358.cflash2", 0x00800000, 0x200000);
+    make_ram(system_memory, &mms->cflash3, "s32k358.cflash3", 0x00A00000, 0x200000);
+    make_ram(system_memory, &mms->dflash0, "s32k358.dflash0", 0x10000000, 0x20000);
+    make_ram(system_memory, &mms->dtcm0, "s32k358.dtcm0", 0x20000000, 0x20000);
+    make_ram(system_memory, &mms->utest, "s32k358.utest", 0x1B000000, 0x2000);
+    make_ram(system_memory, &mms->sram0, "s32k358.sram0", 0x20400000, 0x40000);
+    make_ram(system_memory, &mms->sram1, "s32k358.sram1", 0x20440000, 0x40000);
+    make_ram(system_memory, &mms->sram2, "s32k358.sram2", 0x20480000, 0x40000);
+
+    // CPU: arm-cortex-m7
+    object_initialize_child(OBJECT(mms), "armv7m", &mms->armv7m, TYPE_ARMV7M);
+    armv7m = DEVICE(&mms->armv7m);
+    // Number of interrupts (see interrupt map)
+    qdev_prop_set_uint32(armv7m, "num-irq", 240);
+
+    qdev_connect_clock_in(armv7m, "cpuclk", mms->sysclk);
+    qdev_connect_clock_in(armv7m, "refclk", mms->refclk);
+    qdev_prop_set_string(armv7m, "cpu-type", machine->cpu_type);
+    qdev_prop_set_bit(armv7m, "enable-bitband", true);
+    object_property_set_link(OBJECT(&mms->armv7m), "memory",
+                             OBJECT(system_memory), &error_abort);
+    sysbus_realize(SYS_BUS_DEVICE(&mms->armv7m), &error_fatal);
+
+
+    /* The overflow IRQs for UARTs 0, 1 and 2 are ORed together.
+    * Overflow for UARTs 4 and 5 doesn't trigger any interrupt.
+    */
+
+    // This is the logic used to implement this type of uart
+    // Probably we won't need it
+    Object *orgate;
+    DeviceState *orgate_dev;
+
+    orgate = object_new(TYPE_OR_IRQ);
+    object_property_set_int(orgate, "num-lines", 6, &error_fatal);
+    qdev_realize(DEVICE(orgate), NULL, &error_fatal);
+    orgate_dev = DEVICE(orgate);
+    qdev_connect_gpio_out(orgate_dev, 0, qdev_get_gpio_in(armv7m, 12));
+
+    for (i = 0; i < 4; i++) {
+        DeviceState *dev;
+        SysBusDevice *s;
+
+        // This addresses and irq are correct, but we should implement the right type of uart
+        static const hwaddr uartbase[] = {0x40328000, 0x4032C000,
+                                            0x40330000, 0x40334000
+                                            };
+        static const int uartirq[] = {141, 142, 143, 144};
+        qemu_irq txovrint = NULL, rxovrint = NULL;
+
+        if (i < 3) {
+            txovrint = qdev_get_gpio_in(orgate_dev, i * 2);
+            rxovrint = qdev_get_gpio_in(orgate_dev, i * 2 + 1);
+        }
+
+        dev = qdev_new(TYPE_CMSDK_APB_UART);
+        s = SYS_BUS_DEVICE(dev);
+        qdev_prop_set_chr(dev, "chardev", serial_hd(i));
+        qdev_prop_set_uint32(dev, "pclk-frq", SYSCLK_FRQ);
+        sysbus_realize_and_unref(s, &error_fatal);
+        sysbus_mmio_map(s, 0, uartbase[i]);
+        sysbus_connect_irq(s, 0, qdev_get_gpio_in(armv7m, uartirq[i]));
+        sysbus_connect_irq(s, 1, qdev_get_gpio_in(armv7m, uartirq[i]));
+        sysbus_connect_irq(s, 2, txovrint);
+        sysbus_connect_irq(s, 3, rxovrint);
+    }
+
+    // Timers - refer to page 2816 of the manual (68.7.1)
+    static const hwaddr timerbase[] = {0x400B0000, 0x400B4000, 0x402FC000};
+    // irq from the s32kxxrm interrupt map
+    int irqno[] = {96, 97, 98};
+
+    // Create the timers and connect them
+    for (i = 0; i < ARRAY_SIZE(mms->timer); i++) {
+        g_autofree char *name = g_strdup_printf("timer%d", i);
+        SysBusDevice *sbd;
+
+        object_initialize_child(OBJECT(mms), name, &mms->timer[i],
+                                TYPE_S32K358_TIMER);
+        sbd = SYS_BUS_DEVICE(&mms->timer[i]);
+        qdev_connect_clock_in(DEVICE(&mms->timer[i]), "pclk", mms->sysclk);
+        sysbus_realize_and_unref(sbd, &error_fatal);
+        sysbus_mmio_map(sbd, 0, timerbase[i]);
+        sysbus_connect_irq(sbd, 0, qdev_get_gpio_in(armv7m, irqno[i]));
+    }
+
+    // Address from which load the kernel
+    // The address specified here is usually not used
+    // (only if it's not specified in the elf file)
+    armv7m_load_kernel(ARM_CPU(first_cpu), machine->kernel_filename,
+                       0x00400000, 0x200000);
+}
+
+// Machine init
+static void s32k358_class_init(ObjectClass *oc, void *data)
+{
+    MachineClass *mc = MACHINE_CLASS(oc);
+
+    mc->init = s32k358_init;
+    mc->max_cpus = 1;
+    mc->default_cpu_type = ARM_CPU_TYPE_NAME("cortex-m7");
+    mc->desc = "ARM S32K358";
+}
+
+static const TypeInfo s32k358_info = {
+    .name = TYPE_S32K358_MACHINE,
+    .parent = TYPE_MACHINE,
+    .instance_size = sizeof(S32K358MachineState),
+    .class_size = sizeof(S32K358MachineClass),
+    .class_init = s32k358_class_init,
+};
+
+static void s32k358_machine_init(void)
+{
+    type_register_static(&s32k358_info);
+}
+
+type_init(s32k358_machine_init);
diff --git a/hw/timer/Kconfig b/hw/timer/Kconfig
index 61fbb62b65..a311e189ba 100644
--- a/hw/timer/Kconfig
+++ b/hw/timer/Kconfig
@@ -56,3 +56,7 @@ config STELLARIS_GPTM
 
 config AVR_TIMER16
     bool
+
+config S32K358_TIMER
+    bool
+    select PTIMER
diff --git a/hw/timer/meson.build b/hw/timer/meson.build
index 80427852e0..45b85dbdf6 100644
--- a/hw/timer/meson.build
+++ b/hw/timer/meson.build
@@ -37,3 +37,4 @@ specific_ss.add(when: 'CONFIG_IBEX', if_true: files('ibex_timer.c'))
 system_ss.add(when: 'CONFIG_SIFIVE_PWM', if_true: files('sifive_pwm.c'))
 
 specific_ss.add(when: 'CONFIG_AVR_TIMER16', if_true: files('avr_timer16.c'))
+specific_ss.add(when: 'CONFIG_S32K358_TIMER', if_true: files('s32k358_timer.c'))
diff --git a/hw/timer/s32k358_timer.c b/hw/timer/s32k358_timer.c
new file mode 100644
index 0000000000..aca82878a7
--- /dev/null
+++ b/hw/timer/s32k358_timer.c
@@ -0,0 +1,365 @@
+/*
+ *  s32k358 PIT timer emulation
+ *
+ * SPDX-License-Identifier: CC-BY-NC-4.0
+ * Copyright (c) 2025 Braidotti Sara, Iorio Chiara, Pani Matteo.
+ *
+ */
+
+#include "qemu/osdep.h"
+#include "qemu/log.h"
+#include "qemu/module.h"
+#include "qapi/error.h"
+#include "trace.h"
+#include "hw/sysbus.h"
+#include "hw/irq.h"
+#include "hw/registerfields.h"
+#include "hw/qdev-clock.h"
+#include "hw/timer/s32k358_timer.h"
+#include "migration/vmstate.h"
+
+// Timer's registers: page 2816 manual
+// PIT module control: enables the PIT timer clocks and specifies the behaviour of the timers when PIT enters Debug mode
+REG32(MCR, 0)
+    FIELD(MCR, FRZ, 0, 1) // freeze
+    FIELD(MCR, MDIS, 1, 1) // module disable
+    FIELD(MCR, MDIS_RTI, 2, 1) // module disable RTI
+
+// The RIT and the chaining are not modeled, so we do not create the relative registers
+
+// Timer load value (specifies the length of the timeout peiod in clock cycles)
+REG32(LDVAL0, 0x100)
+REG32(LDVAL1, 0x110)
+REG32(LDVAL2, 0x120)
+REG32(LDVAL3, 0x130)
+
+// Current timer value (indicates the current timer value)
+REG32(CVAL0, 0x104)
+REG32(CVAL1, 0x114)
+REG32(CVAL2, 0x124)
+REG32(CVAL3, 0x134)
+
+// Timer control (controls timer behaviour)
+REG32(TCTRL0, 0x108)
+    FIELD(TCTRL0, TEN, 0, 1) // timer enable
+    FIELD(TCTRL0, TIE, 1, 1) // timer interrupt enable
+    FIELD(TCTRL0, CHN, 2, 1) // chain mode
+REG32(TCTRL1, 0x118)
+    FIELD(TCTRL1, TEN, 0, 1)
+    FIELD(TCTRL1, TIE, 1, 1)
+    FIELD(TCTRL1, CHN, 2, 1)
+REG32(TCTRL2, 0x128)
+    FIELD(TCTRL2, TEN, 0, 1)
+    FIELD(TCTRL2, TIE, 1, 1)
+    FIELD(TCTRL2, CHN, 2, 1)
+REG32(TCTRL3, 0x138)
+    FIELD(TCTRL3, TEN, 0, 1)
+    FIELD(TCTRL3, TIE, 1, 1)
+    FIELD(TCTRL3, CHN, 2, 1)
+
+// Timer flag (indicates the PIT had expired)
+REG32(TFLG0, 0x10C)
+    FIELD(TFLG0, TIF, 0, 1) // timer interrupt flag
+REG32(TFLG1, 0x11C)
+    FIELD(TFLG1, TIF, 0, 1)
+REG32(TFLG2, 0x12C)
+    FIELD(TFLG2, TIF, 0, 1)
+REG32(TFLG3, 0x13C)
+    FIELD(TFLG3, TIF, 0, 1)
+
+static void s32k358_irq_update(S32K358Timer *s)
+{
+    // check if timer is enabled (0 = enabled)
+    if ((s->timer_ctrl & R_MCR_MDIS_MASK)) {
+        // since it is not, clear the interrupt
+        qemu_irq_lower(s->timer_irq);
+        return;
+    }
+
+    // If at least one timer is enabled, has interrupts enabled and the timer interrupt flag set, raise the interrupt
+    for (int i = 0; i < ARRAY_SIZE(s->timers); i++) {
+        if ((s->timers[i].ctrl & R_TCTRL0_TEN_MASK) &&
+             (s->timers[i].ctrl & R_TCTRL0_TIE_MASK) &&
+             (s->timers[i].flag & R_TFLG0_TIF_MASK)) {
+                qemu_irq_raise(s->timer_irq);
+                return;
+        }
+    }
+
+    // clear the interrupt
+    qemu_irq_lower(s->timer_irq);
+}
+
+// Function that allows to read the registers' values
+static uint64_t s32k358_timer_read(void *opaque, hwaddr offset, unsigned size)
+{
+    S32K358Timer *s = S32K358_TIMER(opaque);
+    uint64_t r;
+
+    switch (offset) {
+        // Pit Module Control (MCR)
+        case A_MCR:
+            r = s->timer_ctrl;
+            break;
+        // Timer Control (TCTRL0, TCTRL1, TCTRL2, TCTRL3)
+        case A_TCTRL0:
+        case A_TCTRL1:
+        case A_TCTRL2:
+        case A_TCTRL3:
+            r = s->timers[(offset-A_TCTRL0) / (A_TCTRL1-A_TCTRL0)].ctrl;
+            break;
+        // Current Timer Value (CVAL0, CVAL1, CVAL2, CVAL3)
+        case A_CVAL0:
+        case A_CVAL1:
+        case A_CVAL2:
+        case A_CVAL3:
+            r = ptimer_get_count(s->timers[(offset-A_CVAL0) / (A_CVAL1-A_CVAL0)].timer);
+            break;
+        // Timer Load Value (LDVAL0, LDVAL1, LDVAL2, LDVAL3)
+        case A_LDVAL0:
+        case A_LDVAL1:
+        case A_LDVAL2:
+        case A_LDVAL3:
+            r = ptimer_get_limit(s->timers[(offset-A_LDVAL0) / (A_LDVAL1-A_LDVAL0)].timer);
+            break;
+        // Timer Flag (TFLG0, TFLG1, TFLG2, TFLG3)
+        case A_TFLG0:
+        case A_TFLG1:
+        case A_TFLG2:
+        case A_TFLG3:
+            r = s->timers[(offset-A_TFLG0) / (A_TFLG1-A_TFLG0)].flag;
+            break;
+        default: {
+            qemu_log_mask(LOG_GUEST_ERROR,
+                        "CMSDK APB timer read: bad offset %x\n", (int) offset);
+            r = 0;
+            break;
+        }
+    }
+
+    return r;
+}
+
+// To switch on/off the timer (since it may be enabled/disabled through the s32k358_timer_write funtion)
+static void s32k358_timer_switch_on_off(S32K358Timer *s, uint32_t idx) {
+    ptimer_transaction_begin(s->timers[idx].timer);
+    if ((s->timers[idx].ctrl & R_TCTRL0_TEN_MASK) && !(s->timer_ctrl & R_MCR_MDIS_MASK)) {
+        ptimer_run(s->timers[idx].timer, 0 /* reloadable timer */);
+    } else {
+        ptimer_stop(s->timers[idx].timer);
+    }
+    ptimer_transaction_commit(s->timers[idx].timer);
+}
+
+static void s32k358_timer_write(void *opaque, hwaddr offset, uint64_t value,
+                                  unsigned size)
+{
+    S32K358Timer *s = S32K358_TIMER(opaque);
+    uint32_t idx;
+
+    switch (offset) {
+    // Pit Module Control (MCR)
+    case R_MCR:
+        // Write the first 3 bits, the others are reserved
+        s->timer_ctrl = value & (R_MCR_FRZ_MASK | R_MCR_MDIS_MASK | R_MCR_MDIS_RTI_MASK);
+        // Changing the FRZ and the RTI will have no effect
+        if (value & (R_MCR_FRZ_MASK | R_MCR_MDIS_RTI_MASK)) {
+            // We don't model this.
+            qemu_log_mask(LOG_UNIMP,
+                          "S32K358 timer: FRZ and MDIS_RTI input not supported\n");
+        }
+
+        // If enable the PIT, reset the four timers
+        for (idx = 0; idx < ARRAY_SIZE(s->timers); idx++)
+            s32k358_timer_switch_on_off(s, idx);
+
+        break;
+    // Timer Control (TCTRL0, TCTRL1, TCTRL2, TCTRL3)
+    case A_TCTRL0:
+    case A_TCTRL1:
+    case A_TCTRL2:
+    case A_TCTRL3:
+        // derive the channel
+        idx = (offset-A_TCTRL0) / (A_TCTRL1-A_TCTRL0);
+        // modify only the last three bits, the others are reserved
+        s->timers[idx].ctrl = value & (R_TCTRL0_CHN_MASK | R_TCTRL0_TEN_MASK | R_TCTRL0_TIE_MASK);
+        // Changing the CHN will have no effect
+        if (value & R_TCTRL0_CHN_MASK) {
+            // We don't model this.
+            qemu_log_mask(LOG_UNIMP,
+                          "S32K358 timer: CHN input not supported\n");
+        }
+
+        // if TIF is enabled, changing the timer interrupt enable triggers an interupt (manual - page 2830)
+        s32k358_irq_update(s);
+        // If enable the timer, reset it
+        s32k358_timer_switch_on_off(s, idx);
+
+        break;
+    // Timer Flag (TFLG0, TFLG1, TFLG2, TFLG3)
+    case A_TFLG0:
+    case A_TFLG1:
+    case A_TFLG2:
+    case A_TFLG3:
+        value &= R_TFLG0_TIF_MASK;
+        s->timers[(offset-A_TFLG0) / (A_TFLG1-A_TFLG0)].flag &= ~value;
+        // if TIF=1, it may have to trigger the interrupt
+        s32k358_irq_update(s);
+        break;
+     // Timer Load Value (LDVAL0, LDVAL1, LDVAL2, LDVAL3)
+    case A_LDVAL0:
+    case A_LDVAL1:
+    case A_LDVAL2:
+    case A_LDVAL3:
+        idx = (offset-A_LDVAL0) / (A_LDVAL1-A_LDVAL0);
+
+        ptimer_transaction_begin(s->timers[idx].timer);
+        // Do not reload immediately the timer, wait that it expires before loading the new value
+        // Hence, change the reload value but not the CVAL one
+        ptimer_set_limit(s->timers[idx].timer, value, 0);
+        // Check if the pit and line of the timer are enabled
+        // R_TCTRL0_TEN_MASK is the same for all the registers
+        if (!(s->timer_ctrl & R_MCR_MDIS_MASK) && (s->timers[idx].ctrl & R_TCTRL0_TEN_MASK)) {
+            // Make sure timer is running (it doesn't reset it if it was already)
+            ptimer_run(s->timers[idx].timer, 0 /* reloadable timer */);
+        }
+        ptimer_transaction_commit(s->timers[idx].timer);
+        break;
+    // Current Timer Value (CVAL0, CVAL1, CVAL2, CVAL3)
+    case A_CVAL0:
+    case A_CVAL1:
+    case A_CVAL2:
+    case A_CVAL3:
+        // It is a read-only register
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "S32K358 timer write: write to Read-Only offset 0x%x\n",
+                      (int)offset);
+        break;
+
+    default:
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "S32K358 timer write: bad offset 0x%x\n", (int) offset);
+        break;
+    }
+}
+
+static const MemoryRegionOps s32k358_timer_ops = {
+    .read = s32k358_timer_read,
+    .write = s32k358_timer_write,
+    .endianness = DEVICE_LITTLE_ENDIAN,
+};
+
+// Function called when the timer expires
+static void s32k358_timer_tick(void *opaque)
+{
+    struct sub_timer *st = (struct sub_timer*)opaque;
+
+    // set interrupt flag (always)
+    st->flag |= R_TFLG0_TIF_MASK;
+    // if interrupts are enabled trigger interrupt
+    if (st->ctrl & R_TCTRL0_TIE_MASK) {
+        qemu_irq_raise(st->parent->timer_irq);
+    }
+}
+
+static void s32k358_timer_reset(DeviceState *dev)
+{
+    S32K358Timer *s = S32K358_TIMER(dev);
+
+    for (int i = 0; i < ARRAY_SIZE(s->timers); i++) {
+        /* Set the ctrl and tif */
+        s->timers[i].ctrl = 0;
+        s->timers[i].flag = 0;
+        ptimer_transaction_begin(s->timers[i].timer);
+        ptimer_stop(s->timers[i].timer);
+        /* Set the limit */
+        ptimer_set_limit(s->timers[i].timer, 0, 1);
+        ptimer_transaction_commit(s->timers[i].timer);
+    }
+}
+
+// Model the timer increment
+static void s32k358_timer_clk_update(void *opaque, ClockEvent event)
+{
+    S32K358Timer *s = S32K358_TIMER(opaque);
+    for (int i = 0; i < ARRAY_SIZE(s->timers); i++) {
+        ptimer_transaction_begin(s->timers[i].timer);
+        ptimer_set_period_from_clock(s->timers[i].timer, s->pclk, 1);
+        ptimer_transaction_commit(s->timers[i].timer);
+    }
+}
+
+static void s32k358_timer_init(Object *obj)
+{
+    SysBusDevice *sbd = SYS_BUS_DEVICE(obj);
+    S32K358Timer *s = S32K358_TIMER(obj);
+
+    // Create the memory region in which the timers are memory-mapped
+    memory_region_init_io(&s->iomem, obj, &s32k358_timer_ops,
+                          s, "s32k358-timer", 0x140);
+    sysbus_init_mmio(sbd, &s->iomem);
+    // Connect the irq line and clock
+    sysbus_init_irq(sbd, &s->timer_irq);
+    s->pclk = qdev_init_clock_in(DEVICE(s), "pclk",
+                                 s32k358_timer_clk_update, s, ClockUpdate);
+}
+
+static void s32k358_timer_realize(DeviceState *dev, Error **errp)
+{
+    S32K358Timer *s = S32K358_TIMER(dev);
+
+    if (!clock_has_source(s->pclk)) {
+        error_setg(errp, "S32K358 timer: pclk clock must be connected");
+        return;
+    }
+
+    for (int i = 0; i < ARRAY_SIZE(s -> timers); i++) {
+        s->timers[i].parent = s;
+        // Init the four channels
+        s->timers[i].timer = ptimer_init(s32k358_timer_tick, &(s->timers[i]),
+                           PTIMER_POLICY_WRAP_AFTER_ONE_PERIOD |
+                           PTIMER_POLICY_TRIGGER_ONLY_ON_DECREMENT |
+                           PTIMER_POLICY_NO_IMMEDIATE_RELOAD |
+                           PTIMER_POLICY_NO_COUNTER_ROUND_DOWN);
+
+        ptimer_transaction_begin(s->timers[i].timer);
+        ptimer_set_period_from_clock(s->timers[i].timer, s->pclk, 1);
+        ptimer_transaction_commit(s->timers[i].timer);
+    }
+}
+
+static const VMStateDescription s32k358_timer_vmstate = {
+    .name = "s32k358-timer",
+    .version_id = 2,
+    .minimum_version_id = 2,
+    // only public field, irq and pclk
+    .fields = (const VMStateField[]) {
+        VMSTATE_CLOCK(pclk, S32K358Timer),
+        VMSTATE_END_OF_LIST()
+    }
+};
+
+static void s32k358_timer_class_init(ObjectClass *klass, void *data)
+{
+    DeviceClass *dc = DEVICE_CLASS(klass);
+
+    dc->realize = s32k358_timer_realize;
+    dc->vmsd = &s32k358_timer_vmstate;
+    dc->reset = s32k358_timer_reset;
+}
+
+static const TypeInfo s32k358_timer_info = {
+    .name = TYPE_S32K358_TIMER,
+    .parent = TYPE_SYS_BUS_DEVICE,
+    .instance_size = sizeof(S32K358Timer),
+    .instance_init = s32k358_timer_init,
+    .class_init = s32k358_timer_class_init,
+};
+
+static void s32k358_timer_register_types(void)
+{
+    type_register_static(&s32k358_timer_info);
+}
+
+type_init(s32k358_timer_register_types);
+
diff --git a/include/hw/timer/s32k358_timer.h b/include/hw/timer/s32k358_timer.h
new file mode 100644
index 0000000000..eb7c8b0a08
--- /dev/null
+++ b/include/hw/timer/s32k358_timer.h
@@ -0,0 +1,52 @@
+/*
+ *  s32k358 PIT timer emulation
+ *
+ * SPDX-License-Identifier: CC-BY-NC-4.0
+ * Copyright (c) 2025 Braidotti Sara, Iorio Chiara, Pani Matteo.
+ *
+ */
+
+#ifndef S32K358_TIMER_H
+#define S32K358_TIMER_H
+
+#include "hw/sysbus.h"
+#include "hw/ptimer.h"
+#include "hw/clock.h"
+#include "qom/object.h"
+
+#define TYPE_S32K358_TIMER "s32k358-timer"
+OBJECT_DECLARE_SIMPLE_TYPE(S32K358Timer, S32K358_TIMER)
+
+/*
+ * QEMU interface:
+ *  + Clock input "pclk": clock for the timer
+ *  + sysbus MMIO region 0: the register bank
+ *  + sysbus IRQ 0: timer interrupt
+ */
+
+struct S32K358Timer;
+
+// Data structure representing each timer's channel
+struct sub_timer {
+    struct S32K358Timer *parent;
+    struct ptimer_state *timer;
+    uint32_t ctrl;
+    uint32_t flag;
+};
+
+// Data structure representing the PIT (periodic interrupt timer)
+struct S32K358Timer {
+    /*< private >*/
+    SysBusDevice parent_obj;
+
+    /*< public >*/
+    MemoryRegion iomem;
+    qemu_irq timer_irq;
+
+    Clock *pclk;
+    uint32_t timer_ctrl;
+    struct sub_timer timers[4]; // the timer has 4 channels
+};
+
+#endif
+
